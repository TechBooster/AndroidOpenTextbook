= Webサーバ

Android端末を有効活用する上では、インターネット、あるいはクラウド、そしてそこにあるサーバについて理解し、
それらと通信することが欠かせません。

本章では、Android端末の世界から少し離れ、Webサーバを取り巻く世界を概観してみます。
Webサーバとは「Web」の「サーバ」ですから、
この2つの言葉を取り巻く状況を理解すれば本章の内容が理解できたことになります。

まずサーバから行きましょう。

== クライアント・サーバ・モデル

サーバは英語でserverと書きます。
日本語でも、例えば「ジュースサーバ」「ビールサーバ」といった表現で登場します。
@<fn>{server}

//footnote[server][英語名詞であるserverに対応する動詞（「〜する」）はserveです。これは「〜に仕える」「〜のために働く」という意味です。serverのコンピュータ関連の用語ではない本来の意味は「給仕人」「接客係」です。ちなみに給仕の読みは「きゅうじ」であって「きゅうし」ではありません。]

#@warn(TODO: 「ジュースサーバ」の画像が著作権フリーの画像ではない可能性)

//image[juiceserver][ジュースサーバー]{
//}

「ジュースサーバ」は相手にジュースを提供します。
Webサーバは間違いを承知でしごく簡潔に言えば「Webページを返すサーバ」です。@<fn>{wrong}

//footnote[wrong][この一言では正確でないから、本章があります。]

WebブラウザやAndroid端末は、サーバから見て「クライアント」です。
通常のAndroidアプリを作る限り、「Webサーバから見てAndroid端末やアプリがクライアントである」と考えてしまって構いません。

クライアントであるAndroid端末は、例えばWebブラウザを経由してWebサーバに情報を取りにいきます。
この場合、ざっくりと言えば

 * Android端末はクライアントとしてサーバにデータを取りに行く
 * サーバはクライアントの要求を受け取り、要求に見合ったデータを返す

という作業が発生します。

Webにおいては、WebブラウザやAndroidアプリからWebサーバへWebページなどを「リクエスト」し、Webサーバが「レスポンス」を返します。
requestは「要求」を意味する英単語で、responseは「返答」の英単語です。

WebサーバがAndroid端末に接続してくるということは通常ありません。
「リクエスト」は常にAndroid端末、アプリが行い、「レスポンス」Webサーバが行います。

より一般的に、データを要求する側をクライアント、返答をする側をサーバと呼びます。
「クライアント・サーバモデル」という、インターネット・クラウドで非常に一般的なモデル（考え方）の一つです。

本章を通じて考えていく「AndroidとWeb」の関係では、サーバとクライアントの関係が逆転することはまずありません。
しかしクライアントとサーバ一という役割一般について言えば、逆転は起こりえます。

Webサーバからはちょっと離れて、複数のAndroid端末間でWiFi経由で対戦ゲームを行うケースを考えましょう。
多くのAndroid端末はクライアントですが、どれか一つはサーバになり、その他の端末からの接続を待つのが一般的です。@<fn>{maxio_cart}

//footnote[maxio_cart][携帯ゲーム機のカートゲームなどを想像してみると少し分かりやすいかも。]

まず、サーバ側がゲームを行うための「部屋」を作り、その他の端末の接続を待ちます。
その他の端末はしばしば「ホスト」とも呼ばれるそのサーバへ、クライアントとして接続します。
プレイヤー全員が揃った段階で、ゲームを開始します。

上記のゲーム1プレイが終わった後、別の端末がサーバもしくは「ホスト」の役割は行うこともありえます。
例えばさきほどホストだった人が自宅の用事で帰宅しても、
別の人がホストをすれば同じゲームを一人少ない状態で行うことが出来るかもしれません。
このとき、その別の端末が今度はサーバで、さきほどサーバだった端末はクライアントとなります。

=== P2Pという別のモデル

クライアント・サーバモデルとは別のモデル（考え方）にP2P（ピアツーピア, Peer to Peer）というものもあります。

例えば、電話を考えてみます。
電話をかける側とうける側という立ち位置で見ると、どちらがどちらに電話をかけても問題はありません。
「クライアント・サーバモデル」のように、どちらかが常に待ち受けている必要はないのです。
インターネット電話アプリのSkypeでもそれは似ていて、
相手と通話する際にはどちらからどちらに繋げる（リクエストを投げる）こともできます。

このモデルでは、データを要求する側と提供する側が柔軟に入れ替わるため、どちらがサーバともクライアントとも言えないような通信の仕方をします。
実際の生活でも、インターネット上でも、必ずしも「サーバ・クライアントモデル」が対話を行う唯一のモデル（考え方）ではない、と理解してもらえれば十分です。
@<fn>{server_exists}

Peerは「同僚」といった意味の英語です。
ServerがClientにServe（仕える）という非対称の関係を明確に意図しているのに対して、Peerは通信相手同士が同格であることが明確になっています。

//footnote[server_exists][実際にはかける相手を特定する必要がありますから、電話もSkypeも「交換手」に相当するサーバが存在しなければ成り立ちません。また、一回限りの通信を見ると、最初の接続を受け入れる側と接続しに行く側がいるという意味では、P2Pはクライアントとサーバをとっかえひっかえしている、という見方も出来ます。]


== プロトコルについて学ぶ
=== 相手がいるならルールが必要

相手がいなければ、自分でルールを決めてしまうことが出来ます。

「このデータはHogeHogeClassが持つ」といったルールを途中で変えて、
HogeHogeClassを継承したHogePostClassを新たに実装しても、
ユーザに見えない範囲では文句を言われることはあまりありません。
自分がそれを守れば良いのです。

しかし「クライアント・サーバモデル」や「P2P」のように相手がいる場合、
世界中に分散しているサーバ、人々と通信します。
「ネットワーク」の章でも学んだ通り、相手がいる場合には何らかのルール、つまり「プロトコル」(protocol)が必要です。

インターネットに関する技術的な話を除くと、国家間の外交に関するニュース等で「プロトコル」という言葉を散見する印象を筆者は持ちます。
その場合は「外交儀礼」という意味で、例えば他国の王族をもてなす際には一定の手順、すなわちプロトコルを踏まえるのがならわしです。
破ると、場合によっては外交問題になります。

=== 相手がいる実世界の例: スーパーに梅干しの在庫を問い合わせる

仮想のスーパー「なるえつ」に「大山の梅干し」の在庫があるかを電話で確認する例を考えてみます。

日本のスーパーに対して梅干しを電話問い合わせする場合、
電話番号を入力して相手につながってからは大まかに以下のような流れになるでしょう。

 * （客）（電話をかけて繋げる）「もしもーし」
 * （店）「はい、スーパーなるえつです」
 * （客）「名前も名乗らぬ客です。大山の梅干しはありますか」
 * （店）「少々お待ちください（少し時間を置く）はい、在庫はあります。」
 * （客）「ありがとうございます」（電話を切る）

自然といえば自然な流れです。
ここでやりとりされている情報を分解すると、以下のようになります。
なおこの例では、スーパーなるえつの担当者はサーバで、問い合わせをする側はクライアントと見立てることができます。

まずクライアントからサーバへ接続します。
ついでに「もしもーし」と相手へ挨拶してます。
@<fn>{no_request_on_the_protocol}

//footnote[no_request_on_the_protocol][電話問い合わせの場合、最初の「もしもし」が省略されるケースのほうが多いと思います。電話をかけてつながった時点で店は誰かから会話の要求があったことを理解出来るからでしょう。なお、何かのメッセージを省略できるかどうかもコンピュータの場合はプロトコル（ルール）で決めておく必要があります。]

サーバからの最初の返答で、クライアントは少なくとも相手が「スーパーなるえつ」と名乗っていることを理解します。

次に客は「自分は名乗るつもりはない」と延べ、「大山の梅干し」の在庫に関する情報を求めるリクエストを送っています。
「認証」については後述しますが、ここでは「店は客が誰かを認識していない」という意味です。

「少々お待ちください」は特に人間同士で「そのレスポンスに対する回答には時間がかかる」ことを示すものです。
要求を処理する時間がかかった後、少なくともその要求に対してリソースがあることまでは、サーバ（スーパーなるえつの名前もしれぬ店員）は応答します。

残念ながら、電話口ではインターネットのようにクライアントは本物の梅干しを電話では直接受け取ることはできないので、
ここで電話のやりとりは終わりにして、実際に店舗に行った時に売り切れている恐怖と戦います。

=== プロトコルとは

コンピュータの分野では、プロトコルとは実際に異なる相手同士がやりとりをする約束事のことです。
Webサーバにしろ何にしろ、インターネット上でクライアントとサーバが通信するには、何らかのプロトコルが必要になります。
プロトコルを文字におこした「仕様書」もあった方が、後々のトラブルを防げます

オフィスで席を並べる同僚と一緒にサーバとクライアントを作る状況を考えます。
何もコミュニケーションなしに、二人の考えるデータフォーマットがピタリ一致することは普通ありません。
まず「俺はこういうデータを投げるプログラムを書くからな」という取り決めはきっとします。
「言った」「言わない」問題に発展しないよう、社内Wikiにルールを書いたらそれは立派なプロトコル仕様書です。@<fn>{program_spec}

//footnote[program_spec][プログラムの仕様書なんて要らないという話を聞くかも知れません。本章全体を通じて、仕様書はプログラムのそれではなく、相互にやりとりする上で必要なプロトコルの仕様書のことです。]

アプリ開発と同様、サーバとクライアントの両方をただ一人が作っている場合、プロトコルは自由に変更出来ます。
しかし一般には、相手は別の会社のサーバだったりします。
ルールに基づいてアクセスしないと、無視されたり、あるいは悪者扱いされます。

スーパーなるえつの例では、人間同士でのある程度のプロトコル（しきたり）があるものの、
相手の応答がおかしければ、なんとかする余地がありました。
相手がすずらんの花のことを話し始めたら
「焦るな俺は大山の梅干しが食べたいだけなんだ。」
と返答すれば、もしかすると相手は正気に戻って会話が成立する余地があります。

しかしコンピュータは、人間以上にアドリブに大変弱いです。空気を読めません。
@<fn>{chainber}

//footnote[chainber][「彼はなんと言っている！？」とコンピュータに聞いたとき、コンピュータから丁寧に空気を読む回答をしてくるとすれば、そのコンピュータはチューリングテストにそのまま合格出来たと言えるでしょう。ちなみにチューリングテストとは、ある機械が知的かどうか（人工知能であるかどうか）を判定するためのテストのことです（Wikipedia日本語版「チューリング・テスト」参照）]

コンピュータを用いたサーバとクライアントのやりとりでも、想定外の事態を含めていろいろな状況が起こりえます。
その状況を可能な限り網羅したプロトコル（つまりルール）を仕様書にまとめておき、
クライアントとサーバの両方がそのプロトコルにしたがってデータを要求してデータを受け取る必要があります。
@<fn>{p2p_is_harder}

//footnote[p2p_is_harder][P2Pは、一般的にはサーバ・クライアントモデルよりも面倒な状況がさらに増える傾向があります。例えばWebをP2P的にしようとすると、WebブラウザはWebサーバ「としても」振る舞う必要が出てきますし、逆もしかり。]

=== RFC（Request For Comments）

複数人が共有するプロトコルの場合、特定の誰かが一人でテキトウに決めるのでは問題があります。
その人が悪意を持っていたりすると他の人の迷惑になりますし、その人が気づかない問題があるかもしれません。
インターネットやWebのように大量の異なるプレイヤーが絡む世界でこれは大変困るので、
みんなで議論してみんなでルール（プロトコル）を決め、みんなで一斉に守ります。@<fn>{screw}

//footnote[screw][そもそも、業界の参加者間で仕様を共有するアイディア自体はありふれたものです。例えばネジの規格は種類があるとはいえ、ISOのような国際的な機関によって決められています。ネジを使うメーカーもネジを作るメーカーもそれに従ってものを作れば、とりあえずネジの役割を果たしてくれるはずです。]

インターネット、特に本章の中心であるWebでは、もともと情報をみんなで共有・公開する文化の元に成り立っていましす。
そのため、それを成り立たせるためのWebにまつわるプロトコル仕様は公開で議論され、その結果も自由に見ることが出来ることがほとんどです。
特に、Webに関わる仕様書の多くはRFC（Request For Comments）と呼ばれる一連の仕様書により定義されています。
@<fn>{other_specs}

//footnote[other_specs][なお、RFCがインターネットに関する標準仕様の全てであるかのような記述に見えるかもしれませんが、仕様が全てRFCにまとまっているわけではありません。他の標準化プロセスを持つOASISなど別の団体もありますし、場合によっては標準化について意見がぶつかり合って複数あったりすることも、一応、あります。]

RFCは、IETF（Internet Engineering Task Force）と呼ばれる組織によって発行される、技術仕様等に関する文書全体を指します。
RFCと称されるドキュメントはたくさんあり、それぞれに連番がふられています。
「RFC」のあとに数字をつけ、例えば「RFC 7230」といった形で
特定のRFCを参照します。
現時点でも7000を越えるRFC文書があるのは事実ですが、全部がインターネットで活用されている、というわけではありません。
@<fn>{coffee}

//footnote[coffee][エイプリルフールに発行されるRFCの中には完全にジョークのものがあります。1998年に公開されたRFC 2324の"Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)"などはわかりやすい一例です。私も以前その存在を知り、衝撃を受けた記憶があります。同RFCの"there is a strong, dark, rich requirement for a protocol designed @<b>{espressoly} for the brewing of coffee"（強調引用者）という表現から誰しもがコーヒーの芳醇な香りを想起しつつ、ええと、次へ]

Request For Commentsは日本語に訳すと「コメント求む」です。
しかし実際には、各RFCの文書は公開される前に多くの議論を経た上で公開されており、以後、大きな修正は行われません。
その点で、各ドキュメントは「コメント求む」という表現から想像するよりもはるかに成熟したものとなります。

そのため、「RFC XXXX」（Xは数字）と表現された場合、通常はそれが差す文書は完全に一致します。
誤りについてはerrataとして別の文書として公開されますが、根本的な改善については次のRFCを議論し、過去のRFCを打ち消す形で次に活かします。
古いRFCの側は、文章の内容が訂正されることはありませんので、注意が必要です。
@<fn>{rfc_tool}

//footnote[rfc_tool][@<href>{http://tools.ietf.org/}から参照出来るRFCのHTML（例えば@<href>{http://tools.ietf.org/html/rfc2616}）の場合、obsoleteとなったRFCについてハイパーリンクによって新しいバージョンがあることが分かります。一方、オリジナルのRFCとも言えるテキスト版（例えば@<href>{http://www.ietf.org/rfc/rfc2616.txt}）は本当に修正・変更がされません。]

なお共有されるインターネットの仕様書の中には、企業が独自に策定する、いわゆる「プロプライエタリ」なものもあります。
その場合、その企業の思惑に応じて仕様がねじ曲げられて、利用する他の人が迷惑を被ったりすることもあります。
RFCは言ってみればもう少し「民主主義的」です。
@<fn>{proprietary_is_bad}

//footnote[proprietary_is_bad][Web上で「プロプライエタリ」という表現が使われると、悪いニュアンスとセットであることが多いです。共有や公開を一つの理念としているべきインターネット、という考え方とそぐわないからです。]

これから登場するWebに関わるプロトコルの多くはRFCに基づいたプロトコルが存在します。

=== デファクトスタンダード

プロトコルやその仕様書について書いたので最後に「デファクトスタンダード」についても一言。

デファクト（デ・ファクト、de facto）は「事実上の」という意味を示すラテン語で、名分規定はないものの慣習上使われているルールなどに対して使われる表現です。
対応する明文化された（ある意味で「しっかりした）標準は「デジュールスタンダード」（デジュールは"de jure"）と呼ばれます。

プロトコルやRFCについて明文化された仕様が大事であると説明しましたが、世の中にはしばしば例外が存在し、例外があたりまえのように使われることがあります。

WebにおいてはRFCに書かれた内容に「バグ」があった場合、仕様であるが無視される、あるいは明確に否定されるということが起こることがあります。
仕様を書いた時点では良かれと思ったことが、実際に実装しきってみるととんでもない間違いだった場合、「デジュール」にだけ頼ると世の中が崩壊します。
そこで、最先端ではしばしば「俺らはこのルールは無視する」といったことが正しい目的で行われたりします。

一方その逆に、企業が商業的な理由などで標準外の挙動を示すプロダクトを提供したりすることもままあります。
このように書くとすべてがすべて悪かのようですが、Ajaxを始めとする次世代Webの皮切りとなったのは、
Microsoftが標準も何もない新しい挙動を示すXMLHttpRequestという機能をWebブラウザにとってつけたのが始まりです。

仕様を待ってから実装するのでは遅すぎるし、仕様が常に将来に渡って100%正しいという確信もインターネットでは無理、であるとすると、
明確に書かれた仕様とそうでない挙動の線引きは、いろいろな側面で無理であるし、不合理であるということにもなります。
結果として、RFCのように明確に書かれた仕様の中にも意図通りに世の中で適用されている事例とそうでない事例が混在するという避けられない事態に結びつきます。

Webで使われるルール（プロトコル）にもそういった事例があるため、必ずしも全てがきっちり書かれた通りではない、ということを覚えておいてください。

== Web以外の「サーバ」

本章を始めとする一連の説明は、Webサーバについての説明を中心としています。
しかしインターネット・クラウド上にあるサーバはそれだけにとどまりません。
Webについて本格的に学ぶ前に、その他のサーバについて解説しておきます。

例えば、家庭やオフィスでも以下のようなサーバが設置されていたりします。

 * ファイルサーバ
 * プリントサーバ
 * メールサーバ

「プリントサーバ」について補足しましょう。

Word文書などを印刷したりするために、プリンタを利用することがあります。
昔のプリンタは、USB接続やその他の接続方法でPC1台としか接続・通信できませんでした。

しかし業務用プリンタや最近のプリンタは賢くなっています。
複数台のパソコンやAndroid端末などから「このデータを印刷して」という要求を受けて、印刷を行います。
リクエストを受けて、レスポンスとして印刷するので、これもサーバです。

Webサーバと通信するためにプロトコルとしては後述するHTTPが重要です。
同様に、各サーバではその用途に応じてプロトコルが必要です。

 * メールサーバ ... POP, IMAP, SMTPなど
 * プリントサーバ ... IPP, LPRなど
 * ファイルサーバ ... SMBなど

これらのプロトコルの多くも、RFCのような仕様によって通信方法が定められていたりします。


== Web

ここまでで「サーバ」とそれに関わるプロトコルについての説明が終わりました。
「Webサーバ」とは要は「Web」におけるサーバで、そのためのプロトコルがあります。

では「Web」とは何でしょうか。

webという英単語は、もともと「蜘蛛の巣」を意味する英単語です。
この用語に絡めて、1990年にスイスのCERNという研究所に所属していたTim Berners-Lee博士がWorld Wide Webを提唱したのが、
現在のインターネット上のWebという言葉の始まりです。World Wide WebはWWWと略されることもあります。
@<fn>{internet_existed_before_www}

//footnote[internet_existed_before_www][情報共有を行う手段自体は1990年以前から存在しました。例えばWikipediaの「電子メール」の記事によれば1965年に世界最初の電子メールが使われ始めた、とあります。]

もともと技術論文は、研究分野の他の論文を引用・参照しつつ研究を発展させます。
Web以前からあるコンピュータ上のドキュメントでも、ひとつのドキュメントと
他のドキュメントを相互参照する仕組みは備えていました。
同様に、インターネット上の文章にも同様の構造を作ることが出来るのではないか
という着眼点から、世界全体を一つの蜘蛛の巣と見立てるWorld Wide Webの発想を
提案書の形で公開したのがTim博士です@<fn>{www_proposal}。
一つ一つのハイパーリンクという他のドキュメントへの参照が蜘蛛の糸となります。
この後、1993年にイリノイ大学NCSA（Natiotal Center for Supercomputing Application）
がWebブラウザ"Mosaic"を公開し、大ヒットとなります。
以後、Webの利用は爆発的に普及し、今に至ります。
@<fn>{more_info}

//footnote[www_proposal][最初の提案をW3C（The World Wide Web Consotium）のWebサイト@<href>{http://www.w3.org/Proposal.html}で読むことが出来ます。ブログやTwitterどころかWebページという概念が一般に存在しない時代のことですので、大変先進的と言えます。]

//footnote[more_info][なお本章の説明も含め、WWWの説明はしばしば、まるでTim博士が一人でWorld Wide Webを発明したかのようなニュアンスになりがちなのですが、実際にはいろいろな主体が影響を与え合う中で登場・進化したと考えるのが適切でしょう。例えばWebの成功のきっかけとして紹介されるWebブラウザMosaicはTim博士の発明ではありません。本章執筆担当者が眺めた日本語書籍の中では『Webを支える技術』がおそらく細かな時代背景をよく説明していると思いました。もっと細かくWebの歴史を知りたければそういった書籍をあたってみる方がよいでしょう。]

Webでは当初から、相互にリンクのある「ハイパーテキスト」をWebサーバに配置し、それを人がWebブラウザで見るという用途が想定されています。
これを達成するため、まず3つの主要が重要であると言われます。

 * HTML（Hyper Text Markup Language）は、「ハイパーテキスト」を記述するためのマークアップ言語@<fn>{markup_language}です。
 * URI（Univarsal Resource Indicator）は、世の中のモノ（リソース）を一意に指し示すための文字列の仕様です。
 * HTTP（Hyper Text Transfer Protocol）はHTMLをWebブラウザが要求してWebサーバが返答するやりとり自体に用いるプロトコルです。

//footnote[markup_language][マークアップ言語は「文章の構造（段落など）や見栄え（フォントサイズなど）に関する指定を文章とともにテキストファイルに記述するための言語」です。（Wikipedia日本語記事より）有名なものとしてHTMLがあります！]

=== HTML

本章を読んでいる人はさすがにWebページを全く見たことがないという人はいないでしょうし、
HTMLがWebページを記述するマークアップ言語だということも誰もが知っていることと思います。

そこでここではHTMLの説明を一旦省略します。
URIとHTTPについて時間を割いて説明していき、しばらくした後「HTML5」の文脈でこの言語に再登場を願うことにしましょう。

=== URI（Uniform Resource Indicator）

WebページでリンクをクリックしたときにWebブラウザがインターネットにつながっているのに「それ、どこかわからない」というのでは困ります。
Webで情報をやりとりする際、どのコンピュータのどこにリソースがあるかを一発で指定できる必要があります。
この方法としてURIが規定されています。URIはRFC 3986に詳細な説明があります。

例えば@<href>{http://techbooster.org/}と書けば、後述するHTTPというプロトコルで動作する、
技術サークル「Tech Booster」の、Webサイトの、トップページを示す一意の表現を得ることが出来ます。
@<fn>{homepage}

//footnote[homepage][「ホームページ」という表現は本来特定のWebページの最初のページという意味でしたが一時期「Webページ」と同様に使われていました。そう言えば「ホームページ」や「ホムペ」という表現、最近はあまり聞かなくなりましたね。]

@<list>{uri_format}に同RFCに記載されたURIの例と対応する部品の名前を示しましょう

//list[uri_format][URIのフォーマット]{
     foo://example.com:8042/over/there?name=ferret#nose
     \_/   \______________/\_________/ \_________/ \__/
      |           |            |            |        |
   scheme     authority       path        query   fragment
      |   _____________________|__
     / \ /                        \
     urn:example:animal:ferret:nose
//}

特に上の例（fooというスキームで始まる方）は良く見るものかと思います。
ここでは、それぞれのパーツに名前と役割とルールが決められている点を軽く確認しておくにとどめておきます。
普段WebブラウザでWebページを見る際や、Androidアプリ開発ではURIを事細かに理解する必要はあまりないでしょう。

@<list>{uri_format}のパーツの中には、特に後述するHTTPのGETリクエストで見るqueryの記述もあります。
よくあるのはkey=valueというプログラミング言語で言う辞書型の構造です。
さらに&で文字列を区切って、複数の辞書型データを記述する記法も当たり前のように使われています。

当たり前なのでこれは仕様の一部かと言われると実はそうではないようです。
『めんどうくさいWebセキュリティ』によると、"&"で区切る方法は、実は仕様にはなくデファクトスタンダードです。
確かに同RFCには&で区切るという仕様はどこにも記載されていません。

なので、相当困った際にはここに許されている限りの文字を詰め込んで特殊なことをやっても「仕様違反じゃないもん！」って叫ぶことが出来ます。

その次の#の後に並ぶfragmentでも状況は似ています。
@<fn>{practical_enough}

//footnote[practical_enough][なお、ここで書いていることが馬鹿げた言葉遊び的に見えるかも知れませんが、Webが進化する過程ではプロトコル上の巧妙な抜け道を利用したり、あえてプロトコル違反したりして技術を進化させてきた部分もあり、そのためあながちここの説明も100%馬鹿げた遊びとも言い切れないのが難しいところです。ケースによってはセキュリティ上の問題にそのままつながるため、相当柔軟に複数の側面を理解して応用していく必要があります]


==== URI, URL, URNの違い

HTMLとの連想ではURL（Universal Resource Locator）という表現の方を多く見たかもしれません。
ただし、現在、WebサーバーやHTTPの仕様上で使われる表現はURIです。

歴史的にはURLという概念が先に登場しました。
前述したWorld Wide Webの時点で他のWebページへのハイパーリンクを作成する際に、相手のWeb上の「場所」を特定できる必要があったためです。
実際1994年に、WWWの提唱者であるTim博士が共著者としてRFC 1738 "Uniform Resource Locators (URL)"が発行されています。

しかしその後、リソースを特定する上では「場所」だけでなくその「名前」自体も同様のフォーマットで一意に特定できるべきだ、という議論が主流となります。
最終的に「場所」を示すURLという概念に加えて「名前」を示すURN（Universal Resource Name）も一般的に認知されるようになりました。
@<fn>{other_ur}

//footnote[other_ur][なお他にも"Uniforme Resource"で始める別の概念とフォーマットが提案されたそうですが、現在では一般的ではありません。]

URLとURNは人間で言う氏名と住所の違いに近いと言われます。
例えば商業書籍を考えてみます。
本を一意に認識する上でISBN番号というものがありますが、ISBN番号を表現するURNとして"urn:isbn:4844335340"という文字列を用いることができます。
このURNによって、『Effective Android』という技術書を一意に指し示すことができます。

ただし、URNではEffective Androidという技術書を一意に特定できても、
Web上のどこにその本の情報があるか、どこで購入できるか、といった場所についての情報は伴いません。
その目的のため、Web上の場所を指す場合に「場所」を一意に特定するURLを使用します。
"urn:isbn:4844335340"をオンライン書店Amazonで購入する場合、
@<href>{http://www.amazon.co.jp/dp/4844335340}へアクセスしてください、といった説明ができます。

URLとURNをまとめてURIと呼びます。

URNはWeb上の「場所」を示すことが出来る「URL」としての役割を果たすことはありません。
HTMLのhrefとして記述してもWebブラウザは多分どこにも移動してくれません。
URIということで<a href="urn:ietf:rfc:1458">RFC 1458</a>と書いてもこのリンクはWebブラウザ上では意味がないでしょう。

このRFCの記述を参照する限り、今後のWebに関する議論では、URLに相当する情報を強調する目的がない限りは
全てURIで統一するのが適切ですが、今でもURLという表現がWebサーバやその周辺実装の説明では自然に登場しますので、
読者はどちらが登場しても驚かないようにしておきましょう。



====[column] まだURNのことがわからない場合のもう一例

RFCという言葉について考えてみましょう。
ここまでの説明を読むと「RFC1458」という文字列からはRequest For Commentsの1458番という技術文書のことだと予想したくなります。

しかし実はラジオ福島のことかもしれません。周波数として1458kHzを使っていて、かつ短縮名がRFCなんですね。
@<fn>{radio_fukushima}

//footnote[radio_fukushima][@<href>{http://www.ustream.tv/user/rfc1458}というURIは存在し、どうやらこれはラジオ福島のユーザアカウント情報を表示するWebページのURIです。]

要は「RFC1458」という表現では、世の中の人が同じものを想像をして議論するには不十分です。
一方がその番号の技術文書の内容がダメだという意味で「RFC1458マジダメくさい」とTwitterで書くと、
ラジオ福島の人がそれを見てしょんぼりしてしまうのです(´・ω・｀)

一方urn:ietf:rfc:1458であればRequest For Commentsの1458番であると間違いなく判定できます。

====[/column]

====[column]  JavaのURLクラスとURIクラス

JavaにはURLとURI、両方のクラスがあります。
ここで本章担当者としては紹介せずにいられないJava Puzzleがあります。

http://youtu.be/wDN_EYUvUq0?t=9m50s

相当古い動画なのですが、仕様上今でも問題になるURLクラスとURIクラスのSet内挙動が異なる点を
指摘した例として、当時新入社員だった筆者としても大変驚いた記憶があります。

調べたところ、URLクラスはJDK1.0、URIクラスは1.4の導入とのことです。

どちらかというと初期のJavaのライブラリ設計の失敗に関わるものですが、
「古い」というのはしばしばそういう問題も引き起こす、ということで一つ。

====[/column]

=== HTTP

ネットワークの章でTCP/IPの上で複数の異なるプロトコルのパケットが行き来していることを学んだかと思います。
Webサーバの場合にTCP/IPの上で使われるのは、HTTP（Hypertext Transfer Protocol）というプロトコルです。

Webサーバとやりとりする基本的なプロトコルであるHTTPでは、
クライアントからサーバへ要求（リクエスト、request）を送り、
サーバがそれに対する応答（レスポンス、response）を返します。

HTTPはWebの屋台骨となるもので、理解するのは結構大変です。
まず実際にHTTPで通信される中身を見てからプロトコルの中身を勉強することにします。

==== 演習: telnetでHTTPのリクエストとレスポンスを見てみよう

さてここでHTTPの詳細に踏み込む前に、実際にHTTPのリクエストとレスポンスを体験してみることにします。

ここで登場するのがtelnetというプログラムです。
HTTPのみならずTCP/IP上で動作する各種のプロトコルの検証に使われることがあります。
@<fn>{telnet_has_rfc}

//footnote[telnet_has_rfc][Telnetというのはもともと上述したRFCの中でもRFC 854で規定された立派なサービスの名前ですが、現在telnetと呼ぶ場合、しばしばこれから使う「便利なプログラム」という意味になりがちです]

@<list>{telnet_example}にTech InstituteのWebページヘアクセスした例を示します。
@<fn>{other_web_page}

//footnote[other_web_page][別のWebサイトでも試せますが、まずWebブラウザでそのWebページを表示できること、さらにそのURIがhttpsではなくhttpであること（URIの冒頭のhttpのあとに「s」がついてないこと）を確認してからの方がよいでしょう。この理由については後述します。]

//list[telnet_example][telnetコマンドの実行例]{
$ telnet techinstitute.jp 80[Enter]   <--- "telnet" 以降を入力してエンターを押してください。
Trying XXX.XXX.XXX.XXX...    <--- 実際には正規化されたIPアドレスが表示されます
Connected to techinstitute.jp.
Escape character is '^]'.
GET / HTTP/1.1[Enter]   <--- "GET / HTTP/1.1"と入力してエンターを押してください
Host: techinstitute.jp[Enter]   <--- 上と同様エンターを押します
Session: close[Enter]  <--- 上と同様
[Enter]           <--- 最後に何も入力せずに再度エンターを押します
HTTP/1.1 200 OK
Date: Sun, 06 Jul 2014 06:19:43 GMT
Server: Apache/2.2.23 (Unix) mod_ssl/2.2.23 OpenSSL/1.0.1h
X-Powered-By: PHP/5.5.9
Connection: close
Transfer-Encoding: chunked
Content-Type: text/html

13e
<!doctype html>
<html>
<head>
<meta charset="UTF-8">

..(HTMLぷしゃー)

</html>

0

Connection closed by foreign host.
$   <--- telnetコマンドが終了します
//}

空行でエンターを押した後は、Webサーバが実際にHTTPのレスポンスをtelnetのアプリケーションに返答します。
@<fn>{maybe_bad}

//footnote[maybe_bad][本当は許可を得て使うところです。後述するウェブ・スクレイピング同様、あまりやらかすと本当に怒られるので、本稿を書いている担当者は実はちょっとビビりながら書いています。]

実際に入力した内容を追いかけながら、HTTPのリクエストとレスポンスについて順番に状況を追ってみましょう。

//list[telnet_example_part1][telnetコマンドの実行例（１）]{
$ telnet techinstitute.jp 80[Enter]   <--- "telnet" 以降を入力してエンターを押してください。
Trying XXX.XXX.XXX.XXX...    <--- 実際には正規化されたIPアドレスが表示されます
Connected to techinstitute.jp.
Escape character is '^]'.
//}

@<list>{telnet_example_part1}ではターミナルからtelnetコマンドを実行し、techinstitute.jpの80番ポート（HTTP）へアクセスを指定しています。
これによって、telnetがWebサーバへTCP/IP接続を開始します。

それ以降の3行はtelnetコマンドがコマンドを実行したユーザへわかりやすく文字列を表示しているもので、HTTPとは関係がありません。@<fn>{about_telnet_messages}

//footnote[about_telnet_messages][背後でTCP/IPを介してXXX.XXX.XXX.XXXというIPアドレスのサーバ（の80番ポート）へ接続し、接続が成功したことを伝えています。最後の"Escape character is '^['"は接続をクライアント側から終了する際に、ユーザがCtrl+\]を入力すれば良いことをtelnetコマンド自身が伝えています。]

//list[telnet_example_part2][telnetコマンドの実行例（2）]{
GET / HTTP/1.1[Enter]   <--- "GET / HTTP/1.1"と入力してエンターを押してください
Host: techinstitute.jp[Enter]   <--- 上と同様エンターを押します
Connection: close[Enter]  <--- 上と同様
[Enter]           <--- 最後に何も入力せずに再度エンターを押します
//}

@<list>{telnet_example_part2}ではユーザは実際にHTTPのリクエスト、具体的には「GETリクエスト」を送っています。
説明を端折ったものを@<list>{telnet_example_part3}に示しましょう。

//list[telnet_example_part3][telnetコマンドの実行例（3）]{
GET / HTTP/1.1
Host: techinstitute.jp
Connection: close

//}

最初の行はリクエスト行（Request Line）と呼ばれています。
その次の行から空行までの「〜: 〜〜」で記述された2行は「ヘッダフィールド（Header Fields）」と呼ばれます。

改行コードについて、現在コンピュータ上ではCR、LF、CRLFの3種類がしばしば混在して使われていますが、HTTP 1.1では改行は「CRLF」と決まっています。
@<fn>{telnet_may_not_use_crlf}

//footnote[telnet_may_not_use_crlf][telnetコマンドは実は標準ではCRを改行コードとして送ります。つまり、今回の例だけですと、厳密にはプロトコル違反の改行コードで通信が成立している点は指摘しておきます。大変よくあるプロトコル違反である関係でサーバ側も許容していることが多いのですが、複雑なケースではWebサーバの脆弱性の元になる大変危ういことを実はやっています。ちなみにtelnetから送信する改行コードを変更する方法は、telnetのマニュアルを見ましょう]

3行からなるGETリクエストの冒頭で、実際に取得したいコンテンツとHTTPのバージョンを指定しています。
実は半角空白で区切られた真ん中の"/"がコンテンツの場所を意味しています。
今回の場合この最初の行は"GET http://techinstitute.jp/ HTTP/1.1"と同じ意味です。
ヘッダに含まれている"Host"行と"Connection"行については一旦おいておきます。

//list[telnet_example_part4][telnetコマンドの実行例（4）]{
HTTP/1.1 200 OK
Date: Sun, 06 Jul 2014 06:19:43 GMT
Server: Apache/2.2.23 (Unix) mod_ssl/2.2.23 OpenSSL/1.0.1h
X-Powered-By: PHP/5.5.9
Connection: close
Transfer-Encoding: chunked
Content-Type: text/html

13e
<!doctype html>
<html>

... （HTML）

</html>

0

Connection closed by foreign host.
//}

この部分は全てWebサーバから送られてくる「レスポンス」です。
一行目（"HTTP/1.1 200 OK"）はステータス行（Status Line）と呼ばれ、
実際にWebサーバが返答するHTTPのバージョンと、リクエストがどう処理されたかの「ステータスコード」
が記述されます。
それ以降、空行まではやはり「ヘッダ」です。
ここにサーバの情報や返答してきたデータの種類などが記述されています。
具体的には「Apacheと呼ばれるアプリケーションでホストされていること」
（"Server: Apache/2.2.23 ..."）や
「プログラミングPHPを用いて実装されたサービスであること」
（"X-Powered-By: PHP/5.5.9"）、
「返答したデータがHTMLであること」（"Content-Type: text/html"）
などが記載されています。

そのあと、空行（CRLF）を挟んで、実際のデータです。メッセージボディと呼ばれます。

なお今回の例では、Webサーバへ送ったリクエストの方には、改行の後のメッセージボディを何も入力していません。
これは単にメッセージボディが今回のリクエストでは空であっただけで、場合に寄っては送ることもあります。
例えばWebページでよくある問い合わせフォーム等では実際にボディにデータが入ることがあります。
なので、「最初の1行」「ヘッダ」と「ボディ」という構造は、HTTPのリクエストとレスポンスの両方で共通しています。
@<fn>{chunked}

//footnote[chunked][レスポンスのメッセージボディですが、HTMLの前にこっそり"13e"とあり、さらに末尾に0という数字もついています。つまりHTMLを返すよ、と言っていながらも、Webサーバが実際に返すメッセージボディにはHTML以外の「ゴミ」が混じっています。これはレスポンスヘッダにある"Transfer-Encoding: chunked"の指定があるためです。一般的なHTTP関連の教科書や入門的な説明では、直接HTMLデータだけメッセージボディに入るのですが、今回試したWebサイトがこういうリアルな返答を返したので、ややこしいですがそのまま表記します。HTTPレスポンスについての説明のところでもう少し説明します。]

telnetでHTTPを実際に「しゃべって」みました。
ここからHTTPのリクエストとレスポンスの基本的な構造についてもう少し説明していきます。

#@warn(TODO: Windows8でのtelnetの使い方を書く)
#@# ====[column] Windows8でのtelnetの使い方
#@# ====[/column]

==== HTTPのリクエスト

telnetの例でのリクエストをもう一度見て未ましょう。

//list[telnet_example_part3_2][telnetコマンドの実行例（3）再掲]{
GET / HTTP/1.1
Host: techinstitute.jp
Connection: close

//}

TCP/IPでWebサーバへの接続が完了後、
クライアント（Webブラウザ等）は最初の行（リクエスト行、Request Line）で、リクエストの種類（リクエストメソッド、Request Method）、
リクエストの対象、そして自分が利用しているHTTPのバージョンの3つの情報を指定します。

リクエストメソッドについて、HTTPにはたくさんの種類がありますが、
ここで学ぶのは「GET」リクエストと「POST」リクエストです。
両方共クライアント、つまりWebクライアントの側から送るリクエストの種類です。
その他にはPUT・HEAD・DELETE・OPTIONSなどいくつかありますが、ここでは説明を省略します。
一部後の節で登場します。

ここではGETメソッドの対象として"/"、つまりルートディレクトリのデータを要求しています。
HTTPのバージョンは1.1を期待しています。
大方のWebサーバは要求通りHTTP/1.1でレスポンスを返してくれますが、必須ではありません。

2行目から空行まではヘッダで、必要なフィールドとして"Host"が定義されています。
HTTP/1.1ではこのヘッダ情報は必須です。

"Connection"行は必須ではありませんが、今回はサーバ側の応答の関連でつけています。
今回の例でこれを付けずにGETリクエストを送ることも出来ます。
@<fn>{connection_may_not_close}

//footnote[connection_may_not_close][その場合、上記の例題で使ったサーバでは接続が維持され、次のGETメソッドなどをクライアントがそのまま使えます。大手のニュースサイトではこのような挙動にならないこともあります。動作の詳細はRFCをどうぞ！]

===== GET・POST・その他

GETリクエストはサーバからデータ（もしくはリソース）をダウンロード・取得したいというときに使います。
telnetでの例で使ったメソッドでもあります。
GETリクエストではメッセージボディに相当するものは空であることが一般的です。

POSTリクエストはサーバへデータを送る際に用います。
GETの例では空だったHTTPのリクエスト側のメッセージボディに具体的に値をつめこみます。
メッセージヘッダに"Content-Length: 3000"のようにボディの長さを入れておきます。
このときも、WebサーバからはレスポンスとしてHTMLなどを普通に返送するので、
GETリクエストとPOSTリクエストは画面だけ見るとあまり差に気づきません。

特定のWebページをリロードする際にブラウザが「フォームを再送信しようとしています」と
警告を表示することがあります。これはPOSTリクエストの結果として表示されたページを送信するときに表示されます。

#@warn(TODO: フォームのリロード時の警告のスクショを貼る)

WebサーバがPOSTに関わるデータを重複して送ると、しばしばおかしな結果になります。
インターネット掲示板で同じ投稿を二度受け付けてしまったり、銀行のWebサービスで振込を二度受け付けてしまったりするのです。
サーバ側で対処する方法もあるのですが、POSTなら2度は再送するメリットは普通あまりないため、
ブラウザでも警告を出すわけです。

なお、GETでは警告は出ませんが、URIで説明したクエリ文字列の仕組みを用いると、
実は少量のデータであれば送れます。こちらではWebブラウザからの警告はないので、
GETのクエリ文字列でWebサーバに保存するデータが変わる場合、
このWebページをリロードするのはまずいことがあります。

仕様で強制されているわけではないのですが、
Webサーバの実装のスタイルとしてはGETは「read-only」（読み取り専用）的に動作させるのが一般的です。
クエリ文字列は「検索方法を変える」といった指定にのみ使うべき、と言えると思います。
@<fn>{cachable}

//footnote[cachable][Webにおいてはレスポンスの高速化のためにキャッシュサーバを使うことがあります。HTTPではキャッシュしても良いリクエストについて色々と説明・規定があります。GETリクエストのレスポンスが読み取り専用だとすれば、キャッシュの最有力候補です。ここで、コンテンツに書き込みを行うことをWebサーバが求められていたりすると、キャッシュ出来ません。]

なお、ここではGETとPOSTしか説明しませんが、PUTやDELETEというメソッドもHTTPというプロトコルには存在し、
Webサーバにそのリクエストを行うことが一応出来ます。
ただ、Webブラウザの範囲ではほぼ使うことはありません。
後述するRESTやJavaScriptの文脈で他のメソッドが使われることがあります。
@<fn>{naruetsu_again}

//footnote[naruetsu_again][なるえつの梅干し問い合わせの例をHTTPのメソッドに強引に当てはめると、GETではなくHEADというメソッドに相当します。HEADメソッドをクライアントから送られた場合、Webサーバはリソースがあるかないか、といった情報を返しますが、リソースの中身は返しません。]


==== HTTPのレスポンス

HTTPレスポンスは、リクエストに対する応答です。
telnetの例で現れた例をもう一度見てみましょう。

//list[telnet_example_part4_2][telnetコマンドの実行例（4）再掲]{
HTTP/1.1 200 OK
Date: Sun, 06 Jul 2014 06:19:43 GMT
Server: Apache/2.2.23 (Unix) mod_ssl/2.2.23 OpenSSL/1.0.1h
X-Powered-By: PHP/5.5.9
Connection: close
Transfer-Encoding: chunked
Content-Type: text/html

13e
<!doctype html>
<html>

... （以下HTML）
//}

最初の行でHTTP/1.1とあるのは、サーバが実際にHTTPのバージョン1.1で返答した、という意味です。
リクエストの冒頭の行でHTTP/1.1と書いてあれば大抵ここも同じバージョンを返しますが、
まれに異なる返答がありえます。
HTTP 1.1はHTTP 1.0に対する後方互換性維持が仕様上想定されており、古い1.0が返答されても仕様違反と怒ることは出来ません。
@<fn>{can_contact_using_09}

//footnote[can_contact_using_09][一部の大手サーバでは現在でもHTTP/0.9風のレスポンスを返してくれることがあります。本稿執筆時に間違って"GET /"と書いたらヘッダなし（0.9なので）でHTMLが返ってきて変に感心しました。]

第一行目のステータス行（Status Line）にはHTTPのバージョンのあと、そのリクエストの簡潔な結果をかえす3桁の数字「ステータスコード」（Status Code）が返され、
その後の3桁の数字の説明書きが続きます。
説明書きは数字の定義をそのまま説明したもので、無視できます。

ステータスコードは左端の桁が主要な理由を示しており、残りの2桁でより具体的になります。
ここでは代表的なものをいくつか挙げるにとどめましょう。

 * 200 OK: リクエストで要求されたものが存在したので送りますよ、
 * 301 Moved Permanently: リクエストしたリソースは永久に別の場所へ移動しました。
 * 404 Not Found: そんなリソースは知りません
 * 508 Internal Server Error: サーバ内部でエラーが発生しちゃった！

今回は"200 OK"とあります。そして実際、そのリソースに対応するHTMLが返送されています。
該当するWebページが別のURIで示された場所に移動した場合、代わりに301が返答されることになります。
クライアントが指定したURIに誤りがあったりした場合、サーバは単に「そんなの、ない」と言います。
もしサーバがそのタイミングでエラーを出した場合（例えばJavaでサーバを書いてたとするとNullPointerExceptionでクラッシュしちゃった場合などですね）、
Webサーバは508で「ごめんなさい」します。
ちなみにHTTPレスポンスのステータスコードの200番代は「正常」、300番代は「移転」、
400番代は「クライアント側に問題がある」、500番代は「サーバ側に問題がある」という大まかな区別があります。@<fn>{teapot}

//footnote[teapot][RFC 2324によればHTTPのステータスコード418 I'm a teapotはティーポットでコーヒーを入れようとしたときに抽出するエラーです。クライアントが容器を間違えているのでありまして、紛うことなき400番代の引き締まった香りがいたします]

HTTPではヘッダに"Content-Type"というフィールドを入れることで、メッセージボディの中身がどのような種類のデータかを指定できます。
HTMLを返す場合には"text/html"といった文字列が入りますが、ただのプレーンテキストの場合は"text/plain"と指定すれば、多くのWebブラウザがそれを適切に処理します。
最近ではPDF（Portable Document Format）も一般的で、メッセージボディにPDFを入れることももちろん出来ます。
その場合は"application/pdf"を指定します。@<fn>{mime_type}

//footnote[mime_type][この"text/html"等の記載をMIMEタイプと呼び、RFC 2046で規定されています。そこで実際に記載されうる文字列の標準はIANAという組織が管理しています。「多くのブラウザ」が適切に処理できるのは仕様と標準が定まっているからです。]


Content-Type と呼ばれる情報と、実際のデータ（Content）を返します。
Contentは「中身」です。@<fn>{contents}

//footnote[contents][ちなみに日本語でも「コンテンツ」という表現で使われますが、これはWebページの中身やエンターテイメントのような商品のニュアンスがありますね。ここではあくまで送られてくるデータの中身のことです。]

非常に典型的なのは「このWebページですね。どうぞ」と
「そんなWebページ、ない」という2種類の応答です。

本章では立ち入りませんが、ステータスコードはプロトコルで規定されていつつも、
歴史上の理由でしばしば仕様通りに返答を返してくれないWebサーバもあります。
ここでは「仕様無視！そういうのもあるのか」という程度で軽く理解しておくことにしましょう。


==== 演習: Android アプリからWebサーバにアクセスしてみよう

さて、ここでは実際にAndroid経由でHTTPアクセスをしてみましょう。
ここでは@<code>{java.net.HttpURLConnection}を用いることにします。

#@warn(ネットワークの章でWebサーバへアクセスする事例は終了している可能性が高い。要調整)

====[column] DefaultHttpClientとAndroidHttpClient について

HTTPアクセスを行うライブラリは他にも@<code>{org.apache.http.impl.client.DefaultHttpClient}や
@<code>{android.net.http.AndroidHttpClient}といったライブラリが紹介されることがあります。
しかし本稿ではそれらの理由はおすすめしません。
現時点でこれらの実装にはバグが多く、今後もメンテナンスされる見込みがないと考えられているためです。
なお、非常に古いAndroidのバージョン（2.2）では@<code>{java.net.HttpURLConnection}にバグがあったため、
それらの古いバージョンでは注意が必要です。

 * 参考: Android Apache HTTP Client と HttpURLConnection どっちを使うべき？ @<href>{http://y-anz-m.blogspot.jp/2011/10/androidapache-http-client.html}@<fn>{this_is_also_old_article}

//footnote[this_is_also_old_article][記事の公開2011年10月4日に公開された点も出来れば]

====[/column]

==== 演習おまけ: curlコマンド

telnetコマンドは生のHTTPを見やすいために使ってみましたが、それにしてもちょっと面倒臭いすぎます。
telnetで一つ一つの文字列を丁寧に入れてもサーバの機嫌が良くなったりはしませんし。
@<fn>{shutdown}

//footnote[shutdown][むしろ人間の入力は遅いので、タイムアウトでサーバから切られたりします]

一方Webブラウザで結果を見ると、画像等も表示されて、間違いなく本物のWebページを見ていることになりますが、
telnetのようにその下で何が起きているかを把握はしづらくなります。
特に、ある特定のHTTPリクエストを発行したい、という要望を叶えるのは難しいです。
実際にはtelnetでも、例えばPOSTリクエストを送る場合には手で入力するのは難しいですし、繰り返し試す場合にも不便です。

中間の対策としてしばしば使われる別のコマンドとしてcurlというものがあります。
これはいろいろなHTTPリクエストをサーバに送って見る上ではかなり便利です。

まず、curlで@<href>{http://techinstitute.jp/}というURIにGETリクエストを送る例を示します。

//emlist[curlのGET実行例]{
$ curl http://techinstitute.jp/
<!doctype html>
<html>
<head>
<meta charset="UTF-8">

... （HTMLどびゃー）
//}

これですとヘッダがわかりませんが、-vとつけるとヘッダの内容も見られます。

//emlist[curlのGET実行例。今回はリクエストヘッダとレスポンスヘッダを見る]{
> curl -v http://techinstitute.jp/
* About to connect() to techinstitute.jp port 80 (#0)
*   Trying 157.7.156.136...
* connected
* Connected to techinstitute.jp (157.7.156.136) port 80 (#0)
> GET / HTTP/1.1
> User-Agent: curl/7.26.0
> Host: techinstitute.jp
> Accept: */*
> 
* additional stuff not fine transfer.c:1037: 0 0
* HTTP 1.1 or later with persistent connection, pipelining supported
< HTTP/1.1 200 OK
< Date: Wed, 09 Jul 2014 07:48:07 GMT
< Server: Apache/2.2.23 (Unix) mod_ssl/2.2.23 OpenSSL/1.0.1h
< X-Powered-By: PHP/5.5.9
< Transfer-Encoding: chunked
< Content-Type: text/html
< 
<!doctype html>
<html>
<head>

//}


次にHTTPのPOSTリクエストで、@<href>{http://127.0.0.1:8000/submit}というURIに対して
HTMLフォームから送るかのように"message=Sample Message"というデータを送信する例を示します。

//emlist[curlのPOST実行例]{
$ curl -F "message=Sample Message" http://127.0.0.1:8000/submit
//}

ここでは詳細な説明は避けますが、状況によってはこちらの方が便利なこともある、ということで一つ。
@<fn>{curl_used_later}

//footnote[curl_used_later][特に後述する「プログラマブルな」Webでは大変重宝します。あと、ここで紹介したPOSTの例は本章で後に使います。]


=== HTTPのRFC

本章執筆時点（2014年07月）で、HTTPには0.9、1.0、1.1の3つのバージョンがあります。
IETFのHTTPbisワーキンググループでは現在2.0の仕様策定がされており、最終段階にあるとのことですが、
「そもそもHTTP 2.0はそのまま破棄して次の仕様を作り直すべきだ」と主張する人々もいるため、完全に仕様となるまでは若干注意が必要です。
@<fn>{http20_thrown_out}

//footnote[http20_thrown_out][英語ですが、例えば @<href>{http://www.phoronix.com/scan.php?page=news_item&px=MTcwMTA} などを参照してください。]

HTTP/0.9と1.0については省略し、HTTP/1.1について考えます。
HTTP/1.1は当初、1999年に発行されたRFC 2616を拠り所として15年使われてきました。
しかし曖昧さや現在のWebにそぐわない仕様が盛り込まれていることはよく知られていました。

2014年6月に、このHTTP 1.1の仕様が15年ぶりに改定されました。
現在ではその内容が下記のRFCとして公開されています。

 * RFC7230: Message Syntax and Routing
 * RFC7231: Semantics and Content
 * RFC7232: Conditional Requests
 * RFC7233: Range Requests
 * RFC7234: Caching
 * RFC7235: Authentication

なお、関連して続く4つのRFCもHTTP/1.1の新しい仕様として参照されることがあります。

 * RFC7236: Authentication Scheme Registrations
 * RFC7237: Method Registrations
 * RFC7238: The Hypertext Transfer Protocol Status Code 308 (Permanent Redirect)@<fn>{experimental_rfc7238}
 * RFC7239: Forwarded HTTP Extension

//footnote[experimental_rfc7238][このRFCだけexperimentalです。ステータスコード301も本文で述べた通り"Permenanent Redirect"なのですが、その際にサーバがPOSTリクエストをGETリクエストに書き換えてしまうといった、当初の想定と異なる実装が多いので、再度厳密に定義したものです。ただ、知らないサーバの方が多いので、運用に注意しつつ試す、という意味合いが込められているようです。気になる方はRFC本文を読みましょう]

RFCは同じ分野で新しい仕様を必要とした場合、過去のRFCをobsolete（廃止）扱いとすることで新しい（番号の大きな方の）RFCを利用するよう促します。
旧RFCの内容が書き換わるわけではなく、新RFCの方に廃止扱いのRFCの番号が列挙される仕組みです。

今回の改定でHTTPのバージョンが変化したわけではありません。
HTTP/1.1と呼ぶとき、今後はRFC 2616ではなく上記の一連のRFCのみを参照するようにしてください。
なお、執筆時点で「HTTP RFC」とGoogle検索すると、最初にRFC 2616が検索トップとして表示されたりするため、より注意が必要です。

//image[search-result-for-http-rfc][HTTP RFCの検索結果。サッカーワールドカップ 2014の最中です]{
//}

一連のRFCの策定にも関わっているMark Nottingham氏は自身のブログ記事"RFC2616 is Dead"（RFC2616 は死んだ）
@<fn>{mark_nottingham}で、
「RFC2616は使わないでください。ハードドライブ、ブックマークから削除し、
印刷されているなら全て燃やしてしまうかリサイクルに回しましょう」とまで書いています。 

//footnote[mark_nottingham][@<href>{https://www.mnot.net/blog/2014/06/07/rfc2616_is_dead}]

バージョンが変化していないため、混乱が助長されるのではないか、という考え方も出来る気がします。
しかし筆者がざっと眺めた印象では、そのような懸念を払拭するほどに丹念に作られたRFCであると感じられます。

上記のRFCは、過去の1.1の仕様の曖昧さを排除し、明らかに誤りだった点について今後そういった実装を行わないよう釘をさしつつ、
過去のクライアントやサーバが間違った動作をしても対応できるよう注意が払われています。

また各RFCに過去のRFC 2616からの変更点がそれぞれ補足説明として独立に説明されており、
RFCの変更によって更なる誤解が発生しないところまで配慮されています。
徹底的に考えられているという意味で、大変すぐれたRFCなのではないかと感じます。
全ての文面を確認したわけではありませんが、「堅牢性原則」の鏡のような内容です。
@<fn>{robustness_principle}

//footnote[robustness_principle][「「送信するものに関しては厳密に、受信するものについては寛容に」という通信における原則のことで「ポステルの法則」と呼ばれたりもします。ここでは「新しい実装同士では厳密に、古い実装に対しては寛容に」といったニュアンスで使っています。ちなみに実践するのは大変です]

RFCはそもそも何も知らない人がゼロから読む教科書ではありませんが、本書を一読した読者くらいであれば、
新HTTP 1.1の内容は良い勉強になるだろうと筆者は思います。
@<fn>{new_rfc_is_good}

//footnote[new_rfc_is_good][曖昧さがあるRFCというのは読んでいて非常に辛いものですが、ここまで広範に使われているWebの屋台骨を綺麗に作りなおしただけあって、本当にすごいですねこれ。はい。]

==== Cookie

HTTPはもともと「ステートレスなプロトコル」と言われます。
HTTPの仕様の中には「前回の状態をサーバやクライアントは覚えておいてね♪」と要求している項目がないという意味です。

ここでハンバーガ屋と得意客の例を考えてみます。

#@warn(TODO: このハンバーガ屋の例はステートの意味を取り違えている。変える)

ハンバーガ屋に行き「ツケといてくれ、旦那」と客が支払いを後回しにもできるのがステートフルです。
「ステートフル」は英語でStatefulで、「状態を保持している」という意味です。
ハンバーガ屋は客のツケの金額等を覚えておく必要があります。

ステートフルな場合、次に行った時「この前のツケ、払ってくださいよ」と言うことができるように、
ツケという状態をハンバーガ屋が覚えておけるのが、ステートフルの一見したところ良い点です。
しかし、江戸時代からある下町のハンバーガ屋がお得意客数名に対してこれを行えても、最近の全国チェーンでこれは無理と言えます。
ステートを保持するのはコストがかかります。

というよりも全国チェーンでは「40分後に取りに来ますのでその時に出して」というステートだって、割と断られます。
非常にたくさんのお客を相手にうまくサービスを行き渡らせるには、客は逃げ出さない前提でその場で払ってその場でものをもらうのが通例です。
つまり、自動販売機のように前のことを何も覚えていないのがステートレスです。@<fn>{stateful_burger}

//footnote[stateful_burger][ちなみにこの無理矢理な例で言うと、番号札を渡して店員が後から席に持っていくモデルは、十分ステートフルなサーバです。しかし秒間1万リクエストくらい来る先進的なハンバーガ屋だとこれすら無理です。ステートレス・バーガーが素晴らしいわけです]

しかし実際にWebサーバを介してアクセスすると、
多くのWebサービスでは、ユーザ名とパスワードなど、いろいろなものをWebサーバが記憶しているように見えます。
特に、ブラウザを閉じてもそれらが残っているのは驚きです。

この大方の欲求に対処するのがCookieと呼ばれる仕組みです。
RFC 6265が参照できる仕様ですが、歴史的事情で完全にこのRFCの通りには動作しないとのことです。
@<fn>{rfc6265}

//footnote[rfc6265][Webではしばしばこういう話があります。次の章でもっと生々しい話をご紹介します。]

==== 演習: Cookie

==== SSL接続
==== 演習: UrlHttps を試す


== めんどうくさいWeb

これまで見たWebの一連の技術（HTTP、URI、HTML）は、一見するとシンプルで問題も少なそうです。
しかし詳細に見ていくと一歩間違えると危険な状況に直面する状況が山ほどあります。

例えば以下のHTTPレスポンスを見てみます。
改行コードについては明示的に[CR]や[CR][LF]と明示しました。
@<fn>{from_tangled_web}

//footnote[from_tangled_web][『めんどうくさいWebセキュリティ』のp60からの引用です。]

//list[header_injection_example1][ヘッダインジェクションの例]{
HTTP/1.1 200 OK[CR][LF]
Set-Cookie: last_search_term=[CR][CR]<html><body><h1>Hi![CR][LF]
[CR][LF]
Action completed.
//}

特定のブラウザでは、これは以下のように見える可能性があります。
@<fn>{previous_section}

//footnote[previous_section][混ぜるのは意図的にしろ、CRとCRLFを間違えるなど人間ならやりがちです。前章のtelnetの例に至っては、わかっててやってます。]

//list[header_injection_example1_2][ヘッダインジェクションの例で改行を間違えて展開した場合]{
HTTP/1.1 200 OK
Set-Cookie: last_search_term=

<html><body><h1>Hi!

Action completed.
//}

このように解釈してしまった場合、本来意図した"Action completed."に変わって返答内容の先頭に想定外のHTMLが挟まったように見えます。
「ヘッダインジェクション」「ヘッダスプリッティング」といった名前で呼ばれる立派な脆弱性です。

HTTP 1.1の仕様と言えるRFC 2616は1999年に書かれました。「ドットコムバブル」の頃です。

それから時代と共にWebが進化する過程で、すでに述べたとおりWebも新しい用途に頻繁に使われるようになりました。
また、そもそものRFC 2616では現在ではあまり使われないか、悪用されると上記のような脆弱性
の元になるような機能があり、さらに特定のケースでの曖昧な記述が、
Webサーバやブラウザの挙動の違いを引き起こしたのです。
@<fn>{strict_web}

//footnote[strict_web][ちなみになんでもかんでも厳密であればいいのかと言われれば、普及の観点から言うとそうでもないようです。HTML4がぐっだぐだだったことから、マークアップ言語の厳密性を書き手に矯正するXMLベースのXHTMLという仕様が生まれました。当初はこれで決定打になるかと思いきや、今でもHTML 4.01が使われ、Web上ではあまり流行りませんでした。本章担当者の意見としては「書き手に厳密性を求めたら角をためて牛を殺すようなもの」という印象を持ちます。HTML5はHTML 4.01のように緩くHTMLを書けるように見えますが、マークアップ言語のゆるい部分のWebブラウザでの解釈ルールが実は厳密になっている、ということだそうです。XHTMLは今でもepubのような用途で使われているようです。ちなみに前章のtelnetの例でもCRLFを送るべき所でCRを送っていますので、「厳密」なサーバなら解釈してくれないでしょう。]

一般的に言えば、脆弱性の問題は古いライブラリやそれを使うアプリには残りがちで、一方HTTPのリクエストやレスポンスはユーザから直接見えません。
利便性を追求するために間違った挙動を許すと、それが見えないところでフィッシングサイトなどを手伝う結果になります。
上記の「ヘッダインジェクション」の脆弱性は、対応のまずいWebブラウザでは一切の警告が表示されることなく、全てのHTMLを攻撃者が書き換えられる可能性を意味しています。
当然、現在の最新のWebサーバやブラウザでは対応が行き届いている、はずです。

上記の例ではそもそも、仕様で認められないCRLF以外の改行コードを改行と認識しているから起きる問題です。
一方、たとえ仕様通りであっても、ユーザをトラブルに導きかねない状況はありえます。

一見してシンプルそうなURIについて考えてみます。
例えば@<href>{http://xn--t8jx73hngb.com/}と書かれた時に人間がこのURIが馴染みのあるWebサーバのものかそうでないかを判定できるでしょうか。
@<fn>{punycode}

//footnote[punycode][@<href>{http://お名前.com}をpunycodeを使って書いてみました。試したブラウザではpunycodeを日本語名に自動変換してくれました]

現在Webは世界中で利用されていますから、全ての端末にフォントがあるとは限りません。
フォントがない状態で豆腐が表示されるのを回避するためにpunycode込みのURIが表示されても、
正規のWebサイト化フィッシングサイトかを区別するのは、結構難しいように筆者には思えます。
例えば日本語を読めない人が日本語ドメインのWebサイトとそれに似たフィッシングサイトを見分けるにはどうすればよいでしょうか。
インターネット上のどんな場所でもUTF-8を使えばいいんじゃないか、という意見もあるのですが、
多国語の読めない文字は、脆弱性と組み合わさると結構悲惨です。何が正しい応答かすらわからないわけで。

Webサーバと通信しているクライアントアプリケーション（Androidアプリも含む）は、
こういったサーバサイドの問題に対してユーザへ二次被害を与える可能性があります。

最低でも、自分でHTTPクライアントを自作しよう、とはなるべく思わない方がよいでしょう。
併せて、使うならなるべく安定したライブラリを使う必要がある点も、ここで再度確認しておきましょう。

RESTでHTTP GETを使って値を取るくらいであれば良いのですが、
もし自分のサービスが（WebViewなどを通じて）Webサービスと密に結合している場合、
古いバージョンのAndroid端末をサポートから切る、という判断も必要になることがあります。



== プログラミングインターフェースとしてのWeb

これまで説明してきたとおり、Webは当初、人がコンピュータにアクセスして「ハイパーテキスト」を閲覧するものでした。

しかし現在のWebはそれだけにとどまりません。
Webサーバを介して人を介さずにコンピュータやアプリ同士が通信を行い、
データをやりとりしている世界もまたWebです。

本説ではHTTPやURIという中心的な仕組みはそのままに、
コンピュータ同士が通信する場としてのWebを考えていきます。
当然、この「コンピュータ」には読者が作るであろうAndroidアプリも含まれます。

=== XML、JSON

すでに説明したとおり、HTMLは人が読む「ハイパーテキスト」を記述した言語です。
つまり、そこには人が読める文章があり、リンクがあります。
見栄えを整えるため、CSSのように文章全体、Webページ全体を装飾する必要もあります。

しかしコンピュータ同士であれば、通信する内容は単純な「データ」であるほうが便利です。
CSSのような装飾はむしろ邪魔です。

天気予報の情報をWeb上で収集する例を考えます。
人間が天気予報を見る場合、特定の日付・時間帯の天気、気温、湿度が
図表で表示されているのが理想的です。
もしある特定の地方を見たいのであれば、
地図の上にそれらの情報が載っているのがより使いやすい「天気予報」
になるでしょう。

#@warn(ここに天気予報アプリか天気予報のWebページの画像)

では、アプリがその情報を自動的に取得する場合はどうでしょうか。
アプリ内で画像から欲しいデータを抽出するのは比較的高度で面倒な処理です。
一方、次のようなデータであれば、比較的対処はしやすいでしょう。

#@warn(JSONもしくはXMLの天気予報データ)

人間がWebブラウザを経由してWebサーバから情報を取得する場合、多くの場合はHTMLが返されます。
しかしAndroidアプリが情報を取得する場合、
人が見るために整形されたHTMLを取得するのは冗長です。
別のフォーマットの方がより適しています。

HTTPでは、WebサーバがContent-Type と呼ばれる情報を返してクライアントに返答するデータの種類を返答することはすでに説明しました。
ここで、人が読めるHTMLではなく、XMLやJSONを返答することをWebサーバは選択できるのです。

この場合、HTTP（@<b>{Hyper Text} Transfer Protocol）はもはやハイパーテキストを送るという当初の役割を超えて利用されることになります。
すでにWeb

===[column] ウェブスクレイピング

XMLやJSONのようにアプリで簡単に処理出来る形式でデータを提供してくれない場合があります。
人が読むWebページ（HTML）からパターンを抽出して欲しい情報を取り出すことを「ウェブスクレイピング」と呼び、現在でも行われることがあります。
Googleが検索結果をWeb上から収集するのには必須の方法です。

アプリを開発する上でもしばしば便利と感じることがあるでしょう。
例えば、人気テーマパークの混雑状況を調べることを考えます。@<fn>{warned}

//footnote[warned][すぐに後述する通り、この方法には技術以外の問題があります。逮捕されることもありますので、最後まで読んでから考えましょう。]

来場者や来場を計画している人が見るためのHTMLで書かれたWebサイトはあっても、
XMLやJSONによるデータフォーマットを提供していないことがあります。
そこで、来場者が見るためのWebサイトのHTMLを解析して機械的に解釈できるデータに変換します。
特定のタグの中にある「混雑状況: スッカスカ！」の「スッカスカ！」の部分から
「混雑度が20%未満の場合こう表示されるのだな」と推測するなどして、
アプリのデータとして利用するのです。
ここが「混雑状況: 激混み！」に変わったら、アプリは自動的にそれを検出し、
Androidの通知フレームワークを介してユーザにそれを教えられるわけです。
便利そうですね。

しかし、基本的な考え方の単純さとは裏腹にこの方法は色々と問題を起こすことがあります。

一つ目の問題はWebサーバへの負荷です。XMLやJSONと異なり、この方法でアプリがWebページを読み込む場合、Webサーバは人間が本来読むデータ全体を返します。このとき、Webサーバの前提は「人が読むので一人あたりではそんなに高頻度では来ないだろう」という見込みがあります。

しかしアプリの場合、このアクセスを5秒おきに行うことすら可能です。
要は「F5アタック」をアプリが行い続けるようなものです。
Webサーバからすると、行い方次第では大変迷惑な行為になります。

2つ目の問題は、そもそもそんな用途としてデータを公開することを想定していない、ということです。
XMLやJSONを提供している場合、少なくともアプリから読まれるという意図を持って行っています。
その場合ですら、利用規約等によっては利用方法は限定されます。
HTMLのみで提供される、特に今回の例のような情報は、アプリで自動収集されることを特に望まれてないデータと予想できます。
かりに来場者全員が上の情報を元に計画を立てたとします。
すると「大変合理的な」ユーザの群れが「スッカスカ！」に大挙するなど、
本来のユーザの動きとは大きく異なる状態になるのは明らかです。

もともと、来場者の利便性を向上させるためであることは明らかですが、
運営者は意図を超えての情報利用は嫌がります。
おそらくそのサービスの利用規約にも似たような文面があるに違いないのです。

#@warn(TODO: どこかのサービス規約を読む)

一つ目も問題なのですが、2つ目の問題で世間の常識と技術の常識が乖離していたことから逮捕騒動に至った事例があります。
（「岡崎市中央図書館事件」もしくは「Librahack事件」）
この事例ではサーバ負荷を低減させるためのスケジューラを実装し、技術的にはどう考えても高負荷とは言えない方法でアクセスしたところ、
Webサーバ側に問題があるにも関わらず一方的に逮捕されたという事案です。
本事件は本章筆者が解説出来るレベルを超えているためこれ以上の説明や解釈は行いませんが、
少なくともそういう事件があったことは、アプリ開発者は覚えておくと良いでしょう。

===[/column]

#@warn(TODO: 間に合えば書く)
#@# === 実習: 天気の情報を取ってくる

== Webに関するその他のトピック

うぇぇん。疲れたよぅ

本章はAndroidアプリ開発者のためのWeb講座みたいな状態ですが、
Webというのは地獄のように広いトピックで、書き始めた担当者は泣きたい気分になってます。

本節では説明を取り落とした内容について、キーワードと関連する仕様などについて書き並べていきます。
それぞれの落とし穴なども記述していきますが、詳細は他の記事や書籍で丁寧に勉強することをおすすめします。

ここまでの説明と同じく、理想（仕様）と現実（デファクト）の挙動等には注意を払う必要があります。
真実が一つと言うにはどれも難易度の高いお話です。

=== 認証・認可

 * 認証: 本人確認
 * 認可: アクセス許可

コンピュータの世界から離れて役所で公的な証明書を受け取ることを考えてみます。
例えば、戸籍。

申請書類を書いて、免許証と申請書類を提出し、
役所が大丈夫だと思えば、役所が持っている情報を提供してくれます。

免許証を見せることは自分が本人であることの確認です。
もし「自分である」ことがわかれば、方法は複数あります。

しかし、見せたからと言って、申請する書類の許可が常に得られるとは限りません。
あなたが誰であるか、とその人に何かを行う許可を与えることは別のことです。


===[column] RFCへの「コメント」は誰でもできる

筆者はHTTPとはあまり関係しない別のRFCのワーキングループに積極的に参加したことがあります。
実装上の課題があり、新仕様の一部に旧仕様の問題箇所の修正を入れて欲しかったのです。

変更としては非常にシンプルで説得力があったせいか、特に何の異議もなく採用されました。
最終的に、同RFCのAcknowledgementの項に名前が掲載されました。
普段こういうことはあまりないだけに、結構うれしいものです。

ここで大事なことは、IETFでの議論は一般に広く開かれているということです。
迷惑と判断されるような行動をおこさなければ、
一介の技術者が世界的に使われる仕様に意見を出すことはいつでも可能です。
議論は通常英語で行われます。

===[/column]

=== JavaScriptとWebアプリケーション
==== Androidネイティブアプリ V.S. Webアプリ！？

 * JavaScriptはWebサーバアクセス時にアプリを更新するようなもの。
 ** A/Bテストや頻繁なリリースを実現しやすい
 * JavaScriptからそもそも取得できない端末特有のデータがある場合、Webアプリ単体では無理
 ** 最適なUI。OSが提供する一貫した見栄えに揃えるにはネイティブアプリが圧倒的に楽
 ** ウェアラブルと呼ばれるようなさらに小さい端末ではメモリ使用量等も相まってWebブラウザを起動するのは難しくなってしまう
 * 速度や応答性に極限までこだわる場合、Android上のJavaですら忌避される
 ** ネイティブアプリ V.S. Webアプリなどと言われるが、技術的には「更にネイティブ」になることもあるし、サーバが全て自動的に処理して結果を静的に配信する完全自動化まで幅がある
 ** つまりこの二値比較はいろいろな意味で中途半端とも言えたり。
 * 目標とするサービスの全体像がわかる場合、そこからどの部分をネイティブアプリ的に実装するか、Webサーバに任せるかは決まってくる
 * 結局ケースバイケースですねぇ
 * 非常に一般論で言えば、既存の多くの領域がWebアプリと呼ばれる領域に向かっていく可能性はあると筆者は考える
 ** 利用事例が固まってくると、それに応じて標準化された利用方法、API、仕様が決まり、WebサーバとJavaScriptでそれが容易に利用できるようになるため
 * Webや車載アプリのような、さらにAndroidの世界を広げる用途において、「ネイティブ」なアプリは常に求められることになると予想している


== そして、Webサーバ

本節ではWebサーバからみたWebを考えてみます。
おまけで、Webアプリケーションを作ってみることにしましょう。

=== 基本はHTTPのレスポンスを返すこと

WebサーバはWebのサーバです。
クライアントから来たHTTPリクエストに対するHTTPレスポンスを返します。
WebブラウザやAndroidアプリからはHTTPリクエストを送りますが、サーバから見るとリクエストは「来る」ものです。

//image[server-1][Webサーバはレスポンスをうやうやしく返す]{
//}

例えば、あるWebブラウザが「index.htmlをクレ」と言ったとします。
これに対して「あったよ。これだよ」「ないよ」「別のサーバに聞いて」というHTTPレスポンスを返します。
具体的には、HTTPでは200（Found）、404（Not Found）、301（Moved Permanently）といった
レスポンスの種類に対して番号が対応するところまで、すでに説明しました。

この番号と、必要ならリソースの中身も返すこと、これがWebサーバの基本的な役割です。

クライアントからWebサーバへアクセスがあった場合、目的はWebサーバ上の「リソース」です。
すでにURIの説明であった通り、WebリソースはURIによって一意に識別されるわけですが、
Webサーバから見るとそれを階層構造・ツリー上にマッピングする必要があります。


=== レスポンスの仕方はある程度Webサーバに任されている

URIで指定したリソースについての状態と中身が返ってくれば、クライアントは満足です。
たとえ404（Not Found）でも、クライアントからすれば「ない」ことが重要な情報なこともあります。

「index.html」を要求されれば、Webサーバは大抵、サーバのファイルシステム上のどこかにあるindex.htmlを返すでしょう。

//image[server-2][これがindex.htmlでゲソ]{
//}

ただし、Webサーバが代わりにそのときに内容を作って、HTTPレスポンスで返しても構わないわけです。

//image[server-3][動的にindex.htmlを作成する]{
//}

実際、大手ニュースサイトのトップページはいつもめまぐるしく入れ替わっています。
検索結果もWebサーバ側がいつも変えています。
現在では、Webサーバが情報を加工して返答するのが非常に一般的です。

例えば"Hello World"とだけテキスト形式でHTTPレスポンスを
返すWebサーバがあったとすると、サーバプログラム自体に
Hello Worldという文字を埋め込むだけで済みます。
何かを「覚えて」おく仕組みを用意する必要はありません。

しかし一般的には、Webサーバは何かを「覚えて」いてはじめて意味を持ちます。

例えばAndroidでゲームを作るとき、インターネットランキング機能が欲しいと考えたとします。
Android端末にあるスコアをWebサーバにアップロードしてもらい、
それをスコア順にして表示できるよう、Webサーバは全てのスコアを覚えておく必要があるでしょう。

利用するユーザが少なく、サーバが覚えておくリソースが少量であれば、問題はそこまで難しくありません。
非効率な保存方法や処理をしていて問題になりません。

しかし大量のアクセスがあるWebサーバではある程度工夫が必要です。

//image[server-4][ラフ絵でも連載が成り立つ漫画家はすごい]{
//}

WebサーバはHTTPレスポンスを返すサーバですが、用途に応じてその詳細を入れ替えることは可能です。
プロトコルとしてのHTTPの範囲内であれば、という限定がつくことはもちろんです。

Webサーバを作る最も単純明快な方法は、HTTPレスポンスの「超・絶・簡・単バージョン」を返すプログラムを書いてしまうことです。
ネットワークの章でTCP/IPのソケットプログラミング等を学んでいれば、
このソケット経由で"HTTP/1.1 200 OK"から始まる一連の文字列を返してあげれば、Webサーバの出来上がりです。

//emlist[以下の同じ返答を返すHTTPサーバならもう作れるはずです]{
HTTP/1.1 200 OK
Content-Type: text/plain

Hello world
//}

でもそのレスポンスでは役にたちませんね。いつも200と同じ文字列ですから。

HTTPリクエストに応じて適切な応答を返そうとなると、一気に実装が難しくなります。
すでに説明したWebに関わる面倒な詳細を本当に全て自分で書くのは大変ですし、
前述した「ヘッダインジェクション」脆弱性等を考慮した上で正しい応答を返すのは一筋縄では行きません。
@<fn>{was_easy}

//footnote[was_easy][「そんなん簡単だろー」と実装して、脆弱性が混じって世界に迷惑を撒き散らす迷惑サーバになるということを、多くの技術者が繰り返してきました。一般論です。]

=== Webサーバ（アプリケーション）を「効率良く」実装する

Webサーバと表現した時、現在では単純に静的ファイルを返答するだけのサーバだけを意味しません。
ユーザからの入力をHTTPリクエスト（POSTメソッドなど）で受け入れますし、その内容を覚えておくことになります。
HTTPの仕様に関する各種のコーナーケースも対処しつつ、相手が期待するリソースを適切に提供する、
Androidアプリと同様、ここにWebアプリケーションの必要が発生します。

Webアプリケーションを作りやすくするWebアプリケーションフレームワークが各プログラミング言語ごとに開発されています。
HTTPはすでに大変複雑な技術と化しています。
更に、サーバへアクセスしてくるWebブラウザ側の挙動に問題があったりするため、自力で全てを実装するのは難しくなっています。
Webアプリケーションフレームワークは、そういった問題の多くを解決する方法を提供してくれます。

特に高度なことを達成しようとすればするほど、独自実装にはミスが潜みます。
有力なWebアプリケーションフレームワークではそれぞれ独自にミスを回避する仕組みを提供しています。
特にセキュリティについて言えば、いくつかの典型的な問題には、それぞれ取るべき定番の対策があります。
それを実現するための仕組みを、プログラミング言語やWebサーバを作るためのフレームワークが提供しています。

例えばCSRF（Cross Site Request Forgery）脆弱性@<fn>{csrf_described_later}の多くは、POST送信を行うフォーム等にnonceを埋め込めば防げます。
Webアプリケーションフレームワークではnonceを自動生成して埋め込む仕組み、
それがないPOSTリクエストを遮断する仕組みがあったりします。

//footnote[csrf_described_later][CSRF脆弱性についてはDjangoでWebアプリケーションを作る際に説明します]

全ての脆弱性をWebフレームワークなどで防げるかと言いますと、答えは「いいえ」です。
しかし、防ぎやすい仕組みについてはフレームワーク等を頼ったほうがより素早く安全に開発できます。

と、説明してもよくわからないので、Webアプリケーションフレームワークを使ってみた例を紹介します。
プログラミング言語Pythonとその上で動作するWebフレームワークDjangoという組み合わせにより、
Webサーバ上のアプリケーションを実際に作ることを試みます。
その中で、Webにまつわるこれまでの課題をWebサーバ上ではどのように解決するか、一部をご紹介します。

=== Python + Djangoでサーバを作る。

Pythonはプログラミング言語の一つです。
そしてDjangoはPythonで利用できる有名なWebアプリケーションフレームワークの一つです。
ここまで説明したことをざっとPython + Djangoで実装してみましょう。@<fn>{why_django}
サーバ環境はLinuxのUbuntu系OSを使います。

//footnote[why_django][なぜこの組み合わせかというと、単純に本章担当者が使っているためです]

===[column] IaaS, SaaS, etc.

さて実際にWebサーバ上でWebアプリケーションを動かしてみるのですが、その前に。

Android端末を持っている読者が例を試したい場合、どうすればよいでしょうか。

#@warn(TODO: もう少し書く)

いわゆる「クラウド」の上で今回試すようなサーバを準備することが比較的簡単になっているため、
もし興味があればそちらを調べてみると良いかと思います。

昔は実際のコンピュータを自宅に置いて、Webにそのサーバを公開する、なんていうことも行われていました。
現在ではあまり行われなくなっています。

本章の例では、筆者の開発用Linux端末上でのスクリーンショットを掲載していますが、
特にApache Webサーバ上で動作させることで、
AWSやGCEといった実世界のクラウド環境で実際に世界に公開することもできます。
ただし、CSRF脆弱性やその他の問題もそのまま世界に公開されるので、要注意です。

===[/column]

==== Pythonについて少し

本書はAndroidアプリ開発者にPythonを紹介するものではないため、言語やフレームワークの詳細な説明は省略していきます。

JavaとAndroidアプリを作る場合と比較して、目につく違いについてざっと説明すると以下のとおりです。

 * #以降がコメントとして扱われます。
 * 変数宣言時に型を明示しません（Pythonはいわゆる「動的型付け言語」と呼ばれます）
 * 明示的にコンパイルを行う必要はありません（Pythonはいわゆる「スクリプト言語」と呼ばれます）
 * ブロックはファイル内のインデントによって表現します。
 * 文字列は""と''の両方を使えます。「文字一文字」という型がありません。


==== プロジェクトを作る

Linux環境の/optディレクトリに/opt/helloworldというプロジェクトを作ることにします。

//emlist[helloworldプロジェクトを作る]{
$ python --version
Python 2.7.3
$ django-admin.py --version
1.6.5
$ cd /opt
$ django-admin.py startproject helloworld
$ cd helloworld/
$ ls -R
.:
helloworld  manage.py

./helloworld:
__init__.py  settings.py  urls.py  wsgi.py
//}

django-admin.py はDjangoがもともと提供する管理者用プログラムで、ここではhelloworldというプロジェクトを作っています。
".py"で終わるファイルがPythonスクリプトのファイルです。
ここではhelloworldモジュールがすでに作成されており、プロジェクトの設定を司るsettings.pyを始めとしていくつかの
標準的なファイルが自動的に作られています。


//emlist[helloworldプロジェクトを実行する]{
$ python manage.py runserver
Validating models...

0 errors found
July 08, 2014 - 07:22:45
Django version 1.6.5, using settings 'helloworld.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
//}

この時点でDjangoのプロジェクトは試験用のサーバを立ちあげてしまうことができます。
"python manage.py"はこのプロジェクトを管理するための各種サブコマンドを実行するためのコマンドです。

ここでは"runserver"サブコマンドでDjango組み込みのWebサーバを立ち上げています。
この状態でhttp://127.0.0.1:8000/へブラウザからアクセスすると@<img>{django-01}のようになります。

//image[django-01][作りたてのDjangoサーバ]{
//}

これはDjango自体が表示しているページで自分で表示させているものではありません。

==== DBを用意する

Djangoでは標準の状態で複数のSQLエンジンからバックエンドとして利用することができます。
今回採用したDjango 1.6.5の場合、作られたプロジェクトではすでに
SQLiteというSQLエンジンを使う設定ができているので、
その設定を元に実際にDBを準備してもらうことにします。

//emlist[sqliteを使ってDBを準備する]{
python manage.py syncdb
Creating tables ...
Creating table django_admin_log
Creating table auth_permission
Creating table auth_group_permissions
Creating table auth_group
Creating table auth_user_groups
Creating table auth_user_user_permissions
Creating table auth_user
Creating table django_content_type
Creating table django_session

You just installed Django's auth system,
which means you don't have any superusers defined.
Would you like to create one now? (yes/no): no
Installing custom SQL ...
Installing indexes ...
Installed 0 object(s) from 0 fixture(s)
$ ls
db.sqlite3  helloworld	manage.py
//}

"db.sqlite3"というファイルが作られました。
SQLiteはファイルにデータを保存する軽量のSQL実装で、
独立したデーモンやサーバが要らず軽量でもあるため、
特に実験時のWebサーバ開発や組み込み開発で良く使われます。
@<fn>{android_uses_content_provider}

//footnote[android_uses_content_provider][AndroidでもContentProviderの背後でSQLiteが動いていることはきっとご存知でしょう]

この時点では、サーバで保存するデータについて何も記述してませんが、
Djangoが自身を管理する情報は実はすでにDBに書き込まれています。

SQL文を発行して中身を見てみましょう。

dbshellサブコマンドは、そのプロジェクトで利用されているDBエンジンに合わせてDBとのインタラクティブ環境を起動します。

//emlist[DBの中身]{
$ python manage.py dbshell

sqlite> .tables
auth_group                  auth_user_user_permissions
auth_group_permissions      django_admin_log          
auth_permission             django_content_type       
auth_user                   django_session            
auth_user_groups

sqlite> SELECT * FROM auth_permission;
1|Can add log entry|1|add_logentry
2|Can change log entry|1|change_logentry
3|Can delete log entry|1|delete_logentry
4|Can add permission|2|add_permission
5|Can change permission|2|change_permission
6|Can delete permission|2|delete_permission
7|Can add group|3|add_group
8|Can change group|3|change_group
9|Can delete group|3|delete_group
10|Can add user|4|add_user
11|Can change user|4|change_user
12|Can delete user|4|delete_user
13|Can add content type|5|add_contenttype
14|Can change content type|5|change_contenttype
15|Can delete content type|5|delete_contenttype
16|Can add session|6|add_session
17|Can change session|6|change_session
18|Can delete session|6|delete_session
//}

この例ではいくつかのサーバ側パーミッションがすでに準備されていることが分かります。

==== Hello Worldサーバ

さて最初に"Hello World"とだけ返すWebサーバを作ってみます。

helloworldプロジェクトを作成した時点でhelloworld/ディレクトリに以下のようなファイルが出来ています。
@<fn>{django_may_do_differently}

//footnote[django_may_do_differently][Djangoのバージョンによってもファイルの内容は少しずつ違ってきますが、概略は同じです。]

//emlist[helloworld/urls.py]{
from django.conf.urls import patterns, include, url

from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
    # Examples:
    # url(r'^$', 'helloworld.views.home', name='home'),
    # url(r'^blog/', include('blog.urls')),

    url(r'^admin/', include(admin.site.urls)),
)
//}

ここでは、URIのpath部分を正規表現でチェックしていき、
マッチするものがあればそれに対応する関数にルーティングするという処理をしています。
もともと、そのプロジェクトの管理者用のページとして"admin/"についての実装が入っています。
@<fn>{string_for_regex}

//footnote[string_for_regex][そもそも文字列がシングルクォートで囲われていて気持ち悪いのに、rが先頭に付いていて更に気持ちが悪いかもしれません。例えば"\\\\"とバックスラッシュをバックスラッシュでエスケープするという面倒を避けるために、Pythonではしばしばrを文字列の前に前置してバックスラッシュを特別扱いしない挙動を強制することがあります。なお、rが接頭辞についた文字列自体が自動的に正規表現オブジェクトに変換されるわけではありません。]

ここでWebサーバのトップページに"Hello World"を表示させてみることにします。

//emlist[helloworld/urls.py を改変する]{
from django.conf.urls import patterns, include, url

from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
    url(r'^$', 'helloworld.views.home', name='home'),
    url(r'^admin/', include(admin.site.urls)),
)
//}

一行、意味のある変更を加えています。

//emlist[意味のある部分]{
    url(r'^$', 'helloworld.views.home', name='home'),
//}

これは「HTTPリクエストのURIでpathが何も指定されていないときに」@<fn>{uri_path}
「helloworldモジュール内のviews.pyというファイルにあるhome()関数を実行しろ」、
「このルール自体の名前をhomeとする」という意味になります。
@<fn>{regex}

//footnote[uri_path][URIの各部品の名前を覚えてますか。ここではpathだけ記述し、他の部分はDjangoやDjangoプロジェクトを使うWebサーバが丁寧に処理してくれます]

//footnote[regex][正規表現を学んでいない場合もあると思うので、正規表現部分に当たる^$を説明しましょう。^は先頭です。$は末尾です。つまり「先頭と末尾がくっついている」なので「空の文字列」です。この正規表現自体は文字が入ることを一つたりとも許しませんが、Djangoの機能によって、URIのpathに入る"/"に関連した扱いに実はゆらぎが許されています。]

最初のプロジェクトではviews.pyというファイルがないので、ここで作ります。
@<fn>{django_does_not_recommend_this}

//footnote[django_does_not_recommend_this][この方法を取ると、設定とコードが混じってしまい「後々」問題になるかもしれません。Django公式のチュートリアルでは、ここで"app"と呼ばれる、プロジェクトと独立した再利用可能なモジュールを作り、そちらにコードを配置しています。今回はそのあたりの処理は省略してしまっています。]

//emlist[views.py]{
from django.http import HttpResponse

def home(request):
    return HttpResponse('Hello World\n', content_type='text/plain')
//}

プログラミング言語Pythonではブロックはインデントで表します。
ここではreturnで始まる一行がトップページへクライアントがアクセスしてきた時の処理の全てです。

ブラウザでアクセスしてみます。

//image[django-02][Hello Worldサーバ]{
//}

サーバの実装について、詳細な説明は置いておくとして、
ここで重要なことは「HTTPに関するやりとりのほとんどをDjangoが代わりにやってくれている」ということです。
この例では、本章で説明したHTTPレスポンスのContent-Typeとメッセージボディを、
Djangoが提供するHTTPのユーティリティに単に指定しています。
そして、その結果できた、その名もズバリHttpResponseオブジェクトを返しているだけです。

さて、すでにtelnetコマンドを紹介していますから、ここでtelnetで生のHTTPも見てみることにしましょう。

//emlist[telnetでアクセスする]{
(サーバを立ち上げている状態で)
$ telnet 127.0.0.1 8000
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
GET / HTTP/1.1
Host: localhost

HTTP/1.0 200 OK
Date: Tue, 08 Jul 2014 07:53:30 GMT
Server: WSGIServer/0.1 Python/2.7.3
X-Frame-Options: SAMEORIGIN
Content-Type: text/plain

Hello World
Connection closed by foreign host.
//}

それはともかく、返答はできているようです。
@<fn>{http10_is_used}

//footnote[http10_is_used][HTTP/1.1のリクエストに対してHTTP/1.0のレスポンスが返されている点は興味深いですね]

==== Apache上で実行する

これまでのWebサーバはDjango組み込みでしたが、ここでApacheからこのプロジェクトを実行させてみます。

Apache 2.2系列では、例えば次のように記述します。
@<fn>{apache24}

//footnote[apache24][Ubuntu 14.04 LTS等、Apache 2.4が導入されている場合には@<href>{http://httpd.apache.org/docs/2.4/upgrading.html}も確認してください。Apacheの説明だけで1冊本を書けます。]

//emlist[Apacheの設定例]{
WSGIDaemonProcess helloworld user=www-data group=www-data \
   processes=5 threads=5 maximum-requests=5 umask=0007 \
   python-path=/opt/helloworld
WSGIProcessGroup helloworld
WSGIScriptAlias /helloworld /opt/helloworld/helloworld/wsgi.py
<Directory /opt/helloworld/helloworld>
    <Files wsgi.py>
        Order deny,allow
        Allow from all
    </Files>
</Directory>
//}

Apache上にしかるべきモジュールが準備されていれば、上記のhelloworldプロジェクトがApache配下で実行されるようになります。

Webブラウザ上では結果はそっくり同じに見えるはずです。
ここではApacheに対してtelnetをしてみましょう。
なお今回Apache上に施した設定により、Apache上からアクセスする際に"/helloworld"がパスの先頭に必要になります。

//emlist[Apacheにtelnet接続してDjangoプロジェクトのパスへアクセスする]{
$ telnet 127.0.0.1 80
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
GET /helloworld HTTP/1.1
Host: localhost
Connection: close

HTTP/1.1 200 OK
Date: Tue, 08 Jul 2014 08:09:28 GMT
Server: Apache/2.2.22 (Debian)
X-Frame-Options: SAMEORIGIN
Vary: Accept-Encoding
Connection: close
Transfer-Encoding: chunked
Content-Type: text/plain

c
Hello World

0
//}

Djangoが提供するテストサーバと比べると応答がいくつかの点で異なっているのが分かります。
何より、こちらではレスポンスがHTTP/1.1ですね！

なお、WSGIというのは、ApacheのようなWebサーバとPythonプログラムで書かれたWebアプリケーションがやり取りするための規格です。@<fn>{wsgi_spec}
プロジェクト作成時にすでに作られていたwsgi.pyがこの通信部分の面倒を見てくれますので、
開発者はここでも面倒くさいことを行わずに済みます。

//footnote[wsgi_spec][これまた仕様がありますが、RFCではありません]

//image[server-5][ApacheとDjangoのプロジェクトはWSGIを通じてやり取りする]{
//}

ApacheのようなWebサーバはそれ自体、OS内の静的ファイルをルールに従って返答することが出来ますし、その他のプログラミング言語との通信も行えます。
最近では高速化の観点から、Linux等でNginx@<fn>{about_nginx}という別のWebサーバを採用する事例も増えています。
この場合でも、WSGIという規格を介して同じDjangoプロジェクトを利用してWebアプリケーションをクライアントに提供できます。
@<fn>{django_own_server}

//footnote[about_nginx][「えんじんえっくす」と読みます。@<href>{http://nginx.org/}]

//footnote[django_own_server][本文ではDjango自身が提供するWebサーバも使っていますが、これは開発用で外部公開には全く向きません。まさかHTTP/1.0を返してるとは思いませんでしたが。さて、WSGIを介してスタンドアローンで動作するPython製Webサーバというのもあり、そのうちの一つを筆者も使ってみたことがあります（「異なるバージョンのPython(wsgi)アプリを一つの開発環境上で動かす」@<href>{http://qiita.com/amedama/items/a8f511bd75a14aac0277}）]

==== HTMLテンプレート

HTTPレスポンスで"text/plain"を指定しましたが、HTMLを返すこともできます。
むしろデフォルトでは（何も指定しない場合）"text/html"をContent-Typeとして返します。

//emlist[HTMLを返す場合のhome()関数]{
def home(request):
    return HttpResponse('<html><body>Hello World</body></html>')
//}

このような形でHTMLを書くのは大変面倒です。@<fn>{wrong_html}

//footnote[wrong_html][そもそもここに書かれているHTMLは適切なHTMLではない気がしますね！]

Webサーバが返答するレスポンスにある程度パターンが決まっているのであれば、
Webサーバでそれを共通化・テンプレート化する方が色々と楽です。

Djangoを含むWebアプリケーションフレームワークにはしばしばそういった仕組みがあります。
ちょっと試してみましょう。

//emlist[helloworld/settings.pyに"TEMPLATE_DIRS"の行を足す]{
import os
BASE_DIR = os.path.dirname(os.path.dirname(__file__))
TEMPLATE_DIRS = [os.path.join(os.path.dirname(__file__), 'templates')] # <-- ここが追加部分
//}

//emlist[テンプレートの元になるhelloworld/templates/helloworld/hello.djtmlを作る]{
<!DOCTYPE html>
<html>
  <head>
    <title>Hello World Portal</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  </head>
  <body>
    <h1>{{ message }}</h1>
  </body>
</html>
//}

//emlist[helloworld/views.pyのhome()を修正する]{
from django.core.urlresolvers import reverse
from django.http import HttpResponse, HttpResponseRedirect
from django.template import RequestContext, loader

def home(request):
    template = loader.get_template('helloworld/hello.djhtml')
    context = RequestContext(request, {'message': 'Hello World Again!'})
    return HttpResponse(template.render(context))
//}

結果は@<img>{server-6}通りです。

//image[server-6][あげーん]{
//}

ここで重要なのは、テンプレートとなる"hello.djhtml"に{{ message }}という文字列があり、
対応するhome()関数でその部分を"Hello World Again!"に変えるよう指示していることです。

//emlist[hello.djhtmlでテンプレート化されている部分を再掲]{
    <h1>{{ message }}</h1>
//}

//emlist[views.pyでテンプレート部分に実際に文字列を埋め込む部分を再掲@<fn>{about_dict}]{
    context = RequestContext(request, {'message': 'Hello World Again!'})
//}

//footnote[about_dict][{'message': 'Hello World Again!'}の部分ですが、JavaでいうMapに相当する仕組みです（「辞書型データ構造」などと呼ばれます）。keyは"message"、valueが"Hello World Again!"です。]

そのため、次のようにhome()関数を書き換えると、テンプレート側を変更しなくても最終的なHTMLもそれに応じて変化します

//emlist[views.pyでテンプレート部分に実際に文字列を埋め込む部分を再掲@<fn>{about_dict}]{
    context = RequestContext(request, {'message': 'Good Evening Android!'})
//}

==== POSTとデータの保存

いっそ表示させる文字列をユーザに決めてもらいましょう。
具体的にはHTTPのPOSTで送られてきた文字列をサーバに保存し、トップページでは最新のPOSTの結果を表示するようにしてみます。

保存するためには保存するデータ形式を指定する必要があります。
Djangoの場合、Modelという仕組みを用いて指定し、SQLiteのような特定のDBの制約になるべく依らないデータ構造をプログラム中で使うことができます。
@<fn>{need_to_include_to_app}

//footnote[need_to_include_to_app][今回全く本質的でないので省略しますが、helloworldというプロジェクトをDBを持つAppとして登録しておく必要があります。万が一この説明と同じ作業をされている場合には、helloworld/settings.pyのINSTALLED_APPSという変数の最後に'helloworld'を追加してください。]

//emlist[helloworld/models.pyを新規に作成する]{
from django.db import models

class HelloWorldMessage(models.Model):
    message = models.CharField(max_length=100)
    created_at = models.DateTimeField(auto_now_add=True)
//}

ここでクラスを定義し、クラスにはJavaでいう二つのメンバ変数を作ります。

 * message ... 最大100文字のデータ。今回は"Hello World"の代わりとして使うつもり。
 * created_at ... オブジェクトが作られた日時。今回は「最新の結果」を得るためのソートの鍵で使うつもり。

Pythonではプログラムをコンパイルする必要はありません。
しかしこのようにDjangoのModelを定義した際には、使用しているDBに対応する実際のSQLのテーブルなどをDjangoに作ってもらう必要があります。

//emlist[DBを準備するようDjangoにお願いする]{
$ python manage.py syncdb
Creating tables ...
Creating table helloworld_helloworldmessage
Installing custom SQL ...
Installing indexes ...
Installed 0 object(s) from 0 fixture(s)
//}

先ほど、一度dbshellというサブコマンドでSQLite中のテーブルを見ましたね。
ここでもう一度、DBの中身を見てみることにします。

//emlist[SQLiteの中を再度覗くと、helloworldという文字列が！]{
$ python manage.py dbshell
SQLite version 3.7.11 2012-03-20 11:35:50
Enter ".help" for instructions
Enter SQL statements terminated with a ";"

sqlite> .tables 
auth_group                    auth_user_user_permissions  
auth_group_permissions        django_admin_log            
auth_permission               django_content_type         
auth_user                     django_session              
auth_user_groups              helloworld_helloworldmessage

sqlite> .schema helloworld_helloworldmessage
CREATE TABLE "helloworld_helloworldmessage" (
    "id" integer NOT NULL PRIMARY KEY,
    "message" varchar(100) NOT NULL,
    "created_at" datetime NOT NULL
);
//}

"helloworld_helloworldmessage"というテーブルが新たに作られ、プログラム上で書いた"message"と"created_at"がSQLite上のテーブルのスキーマにあらわれているのが分かります。
Pythonプログラム内でのデータの取り扱いと、SQLエンジンでのデータの取り扱いは、一定のルールに従ってDjangoが代わりに行なっています。

なお、SQLiteではなく、仮にMySQLのような異なるSQLエンジンを使っていた場合にも、同様に適切なテーブルが作られます。
このとき、多くの場合Python側のModelに関する定義を修正する必要はありません。

参考まで、この仕組みをより一般に、プログラム上で見えるオブジェクト（Object）とSQLのような関係データベース（Relational Database）間を
マップする仕組み（Mapper）ということでORM（ORM、Object-relational mapper）と呼んだりします。

さてデータを保存する場所は出来ました。
後はHTTPのPOSTリクエストを受け取る準備をします。
RESTfulには拘らずに/submitというpathにPOSTリクエストがあったら、ということにしましょう。

//emlist[helloworld/urls.pyに"submit"を追加]{
urlpatterns = patterns('',
    url(r'^$', 'helloworld.views.home', name='home'),
    url(r'^submit$', 'helloworld.views.submit', name='submit'),
    url(r'^admin/', include(admin.site.urls)),
)
//}

//emlist[helloworld/views.pyにsubmit()を追加して、home()で結果を使うように変更！]{
from django.core.urlresolvers import reverse
from django.http import HttpResponse, HttpResponseRedirect
from django.template import RequestContext, loader

def home(request):
    result = HelloWorldMessage.objects.order_by('-created_at')
    if len(result) > 0:
        message = result[0].message
    else:
        message = 'Hello World'
    return HttpResponse(u'{}\n'.format(), content_type='text/plain')

def submit(request):
    message = request.POST.get('message')
    obj = HelloWorldMessage.objects.create()
    obj.message = submit
    obj.save()
    return HttpResponseRedirect(reverse('home'))
//}

//emlist[トップページにformを追加する]{
<!DOCTYPE html>
<html>
  <head>
    <title>Hello World Portal</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  </head>
  <body>
    <h1>{{ message }}</h1>
    <form action="{% url 'submit' %}" method="post">
      <input type="text" name="message">
      <input type="submit" value="Submit">
    </form>
  </body>
</html>
//}

//image[server-7][フォームが表示されました]{
//}

そこで、例えば"Hello Android!"と入れて、Submitボタンをクリックします。
これで文字が変わると思いきや。

//image[server-8][謎のエラー]{
//}

おや？

==== CSRF脆弱性と、それを軽減するDjangoの仕組み

#@warn(TODO: CSRF脆弱性の説明がモヒカン耐性を持つ程度に正確か怪しい。要確認)

@<img>{server-8}には英語の説明がズラズラ表示されています。@<fn>{not_shown_on_production}
文中にはDjango特有の説明も多数書かれているのでここで逐一説明することは避けますが、要は「Cross Site Request Forgery」の疑いがある、と警告しています。

//footnote[not_shown_on_production][本番環境では表示されません。具体的にはhelloworld/settings.pyにDEBUGという変数があり、プロジェクトが作成されたときにはこれがTrue（Javaで言う boolean の true）に設定されているため、うやうやしく理由を説明してくれています。本番環境で同じミスがあった場合、HTTPの403（Forbidden）を返します。ここでは説明しませんが、404や403といったステータスコードに対応したHTMLをDjangoに指定することもできます。]

先ほど準備したテンプレートのform部分は大変シンプルです。
単純に「message」というインプットと、ボタンを兼ねる「submit」というインプットの二つしかありません。
ユーザは実際、テキスト入力フィールド一つとボタンだけ見ることになります。
formタグに指定がある通り、この2つのフィールドがPOSTメソッドとともにHTTPリクエストで送信されます。

さて、HTTPの基本的なやり取りを思い出しながら、以下の質問について考えてみてください。
「このPOSTリクエスト、該当するフォームをユーザが実際に入力・確認しなくても送信できませんか？」

実際に見ないで送る例を示します。
HTTPリクエストを送るためのツールcurlコマンドを本章前半でこっそり紹介していました。

//emlist[curlのPOST実行例]{
$ curl -v -F 'message=Malicious Message' http://localhost:8000/submit
//}

仮にDjangoが止めてくれなかったとしますと、このコマンドでメッセージを書き込みたい放題です。
@<fn>{csrf_exempt}

//footnote[csrf_exempt][この機構を無理やり止めた例を少し続けます。具体的には、submit()関数に"@csrf_exempt"という「デコレータ」をつけると、Djangoは今回説明している機構を止めます。]

//image[server-9][Malicious Messageが書き込まれてしまった]{
//}

//emlist[curlのPOST実行例]{
$ curl -v -F 'message=こんにちはこんにちは！ぼくもわもわさん！' http://localhost:8000/submit
//}

//image[server-10][わー、また書き込まれてしまった]{
//}

上の例ではcurlで独立にデータを送信していますが、もっと厄介な方法があります。
悪意のあるWebサイトに同一のPOSTリクエストを送るフォームをこっそり埋め込んでおけるのですね。
このようにすると、そのWebサイトを訪れた善良な第三者が、気づかないうちにこの「攻撃」を行ってしまう可能性があります。

今回の事例では単にトップページが書き換わるだけです。
しかし、仮にログインをして利用するサービスにこの問題があると、困ります。

 * オンラインショッピングサイトなら、ものを買い放題
 * 銀行であれば、送金し放題
 * パスワードを変更し放題

このような実装のWebアプリケーションがある場合
現在のWebの仕組み上、Webサーバからは、そのPOSTリクエストが
その人自身が画面を見て送信してきたものなのか、
悪意のあるWebページからのものなのか、区別する方法がありません。

こういった背景から発生する脆弱性を、一般にCSRF（Cross Site Request Forgery）脆弱性と呼びます。
日本語で言えば「サイト間をまたぐリクエスト強制」で、
ユーザが知らない間に何らかのHTTPリクエストを強制されてる脆弱性、ということです。

さて@<img>{server-9}と@<img>{server-10}は、これまで実装してきた実際のDjangoのアプリケーションの画面ではありませんでした。
実際に表示されたのは@<img>{server-8}です。

実は、DjangoはCSRF脆弱性に関する上記の問題を認識しており、
今回の例ではエラーを表示して、これ以上このPOSTリクエストを処理することを拒否したのです。

偉い！

さて、DjangoはWebサーバを攻撃っぽいものから守ろうとしていますが、ここで私達の「正当な要求」が拒否されている点は問題です。
「正当だ。このフォームから、正しく送ったんだ！」ということを示すものが必要です。

というわけで説明が長くなりましたが、とりあえず今回はフォームに一行追加します。
@<fn>{not_perfect}

//footnote[not_perfect][CSRFの全てをここで説明しているわけではありません。大事なデータの変更の場合「入力」「確認」「完了」の3段階を踏むこともあります。また、CSRFを防ぐ方法は他にも「直前でもう一度パスワードを求める」「ハードウェアトークンの値を要求する」など、幅があります。IPA（情報処理推進機構）がオンラインで無料公開している「安全なウェブサイトの作り方」など、無料で得られる信頼性の高い情報もありますので、そちらも参照してください。]

//emlist[トップページのフォームを改良する]{
<!DOCTYPE html>
<html>
  <head>
    <title>Hello World Portal</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  </head>
  <body>
    <h1>{{ message }}</h1>
    <form action="{% url 'submit' %}" method="post">
      {% csrf_token %}
      <input type="text" name="message">
      <input type="submit" value="Submit">
    </form>
  </body>
</html>
//}

{% csrf_token %}を追加しただけですが、これでこのフォームは完成です。
@<fn>{csrf_token_is_mentioned}

//footnote[csrf_token_is_mentioned][エラー画面をよく見ると実際、ここで追加している内容を提案しています。]

実際にWebサーバに送られるHTMLを見てみましょう

//emlist[実際に送られてきた内容の一例]{
<!DOCTYPE html>
<html>
  <head>
    <title>Hello World Portal</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  </head>
  <body>
    <h1>Hello World</h1>
    <form action="/submit" method="post">
      <input type='hidden' name='csrfmiddlewaretoken' value='MlTmHwtCNrLgCjsbpRzoCL9bNbVjIQW' />
      <input type="text" name="message">
      <input type="submit" value="Submit">
    </form>
  </body>
</html>
//}

csrfmiddlewaretokenの値が、簡単には予測不可能な値である点に注目します。

//emlist[おわかりいただけただろうか？]{
      <input type='hidden' name='csrfmiddlewaretoken' value='MlTmHwtCNrLgCjsb :-) pRzoCL9bNbVjIQW' />
//}

あ、間違えた。

//emlist[CSRF脆弱性を防ぐための秘密の値が埋め込まれている]{
      <input type='hidden' name='csrfmiddlewaretoken' value='MlTmHwtCNrLgCjsbpRzoCL9bNbVjIQW' />
//}

この値は、Django自身が、擬似乱数を用いて独自に生成したものです。
自身のDBの中に保存しておき、以降のPOSTリクエストでこの値が埋め込まれているかをチェックします。

ここで説明した、CSRF脆弱性がこれでどう守れるでしょうか。
少なくとも、curlコマンドは上記のトップページ（フォームが表示されるページ）をその都度見るまで動作しません。
csrfmiddlewaretokenというフォーム内の値を予測できないためです。
同様に、攻撃者のWebページからも、直接有害なPOSTリクエストを送れなくなりました。
正確には、そのPOSTリクエストはDjangoによって拒否されます。

少なくとも、明らかなCSRF脆弱性は、少し遠のいたようです。
@<fn>{in_cookie}

//footnote[in_cookie][ユーザ専用の秘密が使いまわされてしまいそうですね。実は HTTP Cookie にも情報を残していて、双方をPOSTリクエスト時にDjangoが後ろでチェックしています。ですので、単なる使い回しはうまく行きません。ただし、Cookieの中身が漏れるとまずいことがありそうです。ところで、Cookie漏れの脆弱性というのも、世の中には存在します。気になったら『めんどくさいWebセキュリティ』もどうぞ。]

==== おおっと、クロスサイトスクリプティングはどうした！

比較的話題に上がりづらいCSRF脆弱性ばかり説明していましたが、世の中の脆弱性はこれだけではありません。
特に有名なクロスサイトスクリプティング脆弱性、今回はどうでしょうか。

試してみましょう。

#@warn(TODO: 試せ)

====[column] RESTfulは？

今回は、REST風のインターフェースでした。
RESTfulの説明もしたのだから、概要くらいは書いたほうが良さそうですね。

まず、Djangoが提供するHttpRequest、HttpResponseオブジェクトは
HTTPのやりとりの多くを柔軟に行う方法を多数提供しています。
HttpRequestオブジェクトではmethodというメンバ変数が"GET"や"POST"といったHTTPのメソッドを文字列で保持しており、
HttpResponseオブジェクトはステータスコードを保持するstatus_codeというメンバ変数を持ちます。
後はpathをRESTfulに見合った方法で記述すれば、RESTfulなWebアプリを作ることができます。
@<fn>{django_is_good_for_rest}

//footnote[django_is_good_for_rest][『RESTful Webサービス』では12章「RESTfulサービスのためのフレームワーク」でDjangoによる同書の実践方法が記述されています。「Djangoは主にWebアプリケーションに使用されるが、RESTful WebサービスをPythonで実装するのに申し分ない土台になる」(同書 p385)]

異なるアプローチもあります。
例えば、Django本体に追加して、Django REST framework（@<href>{http://www.django-rest-framework.org/}）を用いる方法があります。
ここでは説明を省略しますが、これをさらに用いてRESTfulなサービスを構築することも出来ます。

====[/column]

== さらなる学習のために

本章ではWebサーバと通信する上で必要な基礎知識について説明し、最後にWebサーバを実際に実装する過程も説明しました。
しかし、WebとWebサーバを理解する上では、多くの面でまだ不足があります。

本章の最後に参考書籍をいくつか挙げていきますので、適宜参照してみてください。

 * 『HTTPの教科書』翔泳社
 * 『Webを支える技術』技術評論社
 * 『めんどうくさいWebセキュリティ』
 ** 基本的な解説を読んで「簡単そう」と思ったら読んでみましょう。いわゆるコーナーケースの瑣末さとセキュリティの関係を理解するに連れて吐き気がしてきます。
 * 『コンピュータネットワーク 第5版』
 ** タネンバウム博士によるネットワークの教科書です。第7章 アプリケーション層の説明の一つとしてWorld Wide Webの説明と、第8章のネットワーク・セキュリティが読者の興味を引くかも知れません。どちらかというと「ネットワーク」の章の参考書籍と言えるかもしれません :-P
 * http://www.html5rocks.com/ja/tutorials/internals/howbrowserswork/
 ** ブラウザ側。
 * 『過負荷に耐えるWebの作り方』
 ** 第一回AKB総選挙のWebサーバがどう作られたかが書かれた本です。高負荷なWebサーバの構成やテスト方法等が書かれており、端末側から見えない部分の概要を知りたい方には中々良い本です。
@<fn>{akb_math}
 * 『RESTful Webサービス』

//footnote[akb_math][個人的に超知りたいのは、投票権で使われたというシリアル番号生成アルゴリズムですが、そこは書いてないんですよね]

なお、本章執筆時点で参考文献を読む上で特にややこしいのは、すでに本章で紹介したHTTP 1.1の仕様改定があったことです。
HTTP/1.1という表現で差すものが、各書籍の時点と大きく変わっています。

以前に出版されたHTTP 1.1に関わる書籍は、しばしば「既存のHTTP 1.1の問題」という形でRFC 2616に関わるHTTP 1.1の落とし穴や問題点を指摘しています。
しかし、新仕様によってそれらの一部は「バグ修正」されていたりして仕様に関する問題そのものが消滅していることがあるため、
そういった問題点の多くは教養としても理解する意味が薄くなっているように感じられます。
@<fn>{implementation_wont_yet}
@<fn>{http_20_will_solve}
特にHTTPというプロトコルに特化して何かを調べたい、という場合には特に注意してください。
@<fn>{use_latest_web_framework}

//footnote[implementation_wont_yet][実装に関わる問題は新RFCとは独立して発生しているため、事情が異なります。サポートの切れたWebサーバ実装の特定のバージョンを使い続けていたり、サポートの切れたOSのWebブラウザを使っていたりする場合、いかに仕様が良くなっていたってそれに合わせて実装を修正してくれる人がいません]
//footnote[http_20_will_solve][ある書籍では「きたるHTTP 2.0が解決してくれるに違いない」という文面も見ました。HTTP/1.1自身が実は変わる、という可能性には気が付かなかった模様です。実際、バージョン番号まで決まって10年以上安定している仕様自体がまるっと修正されるとは思いませんよね]

//footnote[use_latest_web_framework][本章で紹介したDjangoのようなWebアプリケーションフレームワークを使う場合はHTTPの仕様自体よりも、それに準拠した最新のフレームワークがないかを調べるほうが良いです。もし仮に仕様に準拠していないためにAndroidアプリから見ても不具合が生じるようなことがあった場合には、直接フレームワークの開発元に連絡をするか、別のフレームワークを探すか、最終手段として自分で作る必要があります。Apacheのプロキシ機能があまり良くないためにnginxという別のWebサーバが作られた、という記事を、ええと、さっき読みました]

