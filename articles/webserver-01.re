= Webサーバ
== 説明する予定のこと

本章では、Android端末の外側の世界にあたる、Webサーバと通信する際に役に立つ基礎知識を説明します。



== サーバの役割

Android端末は独立したコンピュータとして非常にパワーがあります。
しかし、他のユーザとデータをやりとりしたり、
端末を切り替える際にデータを移行したり、
複数の端末で一つの情報を共有したりするには足りません。

そこでサーバの役割です。

== サーバ、クライアント

サーバという言葉は、英語で言えばserverで、日本語でも例えば
「ジュースサーバ」「ビールサーバ」といった表現で登場します。

//image[juiceserver][ジュースサーバー]{
//}

英語名詞であるserverに対応する動詞（「〜する」）はserveです。
これは「〜に仕える」「〜のために働く」という意味です。
serverはserveする人、という意味で、
コンピュータ関連の用語ではない本来の意味は「給仕人」「接客係」です。
つまり、仕える・給仕する相手が前提にある表現です。@<fn>{kyuuji_nin}

//footnote[kyuuji_nin][ちなみに給仕の読みは「きゅうじ」であって「きゅうし」ではありません。]

コンピュータ関連用語では、サーバが仕える相手を「クライアント」と呼びます。
こちらの元の英語はclientです。
@<fn>{about_client}

//footnote[about_client][日本語でも、お客さんを「クライント」と呼ぶ職業があります。]

Android端末は多くのケースでクライアントとして振る舞います。

クライアントであるAndroid端末は、
例えばWebブラウザを経由してWebサーバに情報を取りにいきます。
この場合、ざっくりと言えば

 * Android端末はクライアントとしてサーバにデータを取りに行く
 * サーバはクライアントの要求を受け取り、要求に見合ったデータを返す

という作業が発生します。

== サーバとクライアント間のルール

「クライアントはデータをサーバに取りに行き、
サーバはデータをクライアントに送る」のですが、
では「具体的にどうやって」行うのでしょうか。

「ネットワーク」の章でも学んだ通り、
相手がいる場合には何らかのルールが必要です。
これを「プロトコル」(protocol)と言います。

特にコンピュータは、基本的にはアドリブに弱いです。
すべてのケースにおいて、しっかりしたプロトコル
を準備しておき、クライアントとサーバの両方が
その振る舞いにしたがってデータを要求して
データを受け取る必要があります。

ネットワークのいわゆる「TCP/IP」といった
プロトコルだけでは、Webサーバ上のデータを
やりとりするのには不足です。

例えば、近所のスーパー「なるえつ」に
大山の梅干しの在庫があるかを確認するために、
携帯電話から電話をかけたとしましょう。

通話して相手につながりました。
さてそこで、相手が"Hello, this is Mike"
と言ってきたとします。
日本語での応答を期待していたとすると、
これは困ります。

あるいは「مرحبا، أنا جون ماكين.」と
群馬語で応答が来ても、やっぱり困ります。
最低限、日本語で応答して欲しいです。

 * 「はい、スーパーなるえつです」
 * 「客です。大山の梅干しはありますか」
 * 「少々お待ちください……在庫ありました」
 * 「ありがとうございますガチャっ」

ラフに書けばこのくらいの応答がありえます。
最初の相手側（サーバーです！）は
電話の応答口が「スーパーなるえつ」
であると言っています。

ここで突然
「今朝丸ノ内線で、すずらんの花が咲きました」
と語られるのは困ります。

非常に適当な例で恐縮です。
でも「電話がつながる」ことと
「必要な情報を得られる」ことの間には
まだ隔たりがあることがわかります。

コンピュータの話に戻りますと、
「電話がつながる」ところまでが行ってみれば
TCP/IPが保証するレベルと考えるのが今はわかりやすいと思います。
でもこのあと、日本語である必要があるし、
日本語にしても適切な応対の幅があるというのもわかります。

Webサーバの場合、クライアントはサーバが
持っている特定のデータをほしいと思っていることが
まず一般的です。
Webページというのは、そういうものですね。

== ルール HTTP

一般的な社会でも、ルールはみんなで決めますし、
決まったものは守ります。

Webサーバの場合に使われるのは、
HTTP（Hypertext Transfer Protocol）
というプロトコルです。
このプロトコルの詳細はRFCと呼ばれる文書により定義されます。

=== RFCとは

RFCはRequest For Commentsの略です。
IETF（Internet Engineering Task Force）と呼ばれる
組織によって発行される、技術仕様等に関する文書を指します。
IETFは特にインターネットで利用される標準について議論を行う組織です。
議論する対象に応じてワーキンググループを作成し、
メーリングリストでの議論の後、RFCを発行するなどして
そのワーキンググループの活動を一旦終了します。
TCP/IPに関わる仕様もIETF由来です。

RFCと呼ばれるドキュメントはたくさんあり、それぞれに連番がふられています。
「RFC」のあとに数字をつけ、例えば「RFC 7230」といった形で
特定のRFCを参照します。@<fn>{many_rfc}

//footnote[many_rfc][現時点でも7000を越えるRFC文書があるのは事実ですが、全部がインターネットで活用されている、というわけではありません。特にエイプリルフールに発行されるRFCの中には完全にジョークのものがあります。1998年に公開されたRFC 2324の"Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)"などはわかりやすい一例です。同RFCの2.3.2 "418 I'm a teapot"は私が学生時代にも衝撃を受けた記憶があります。]

Request For Commentsは日本語に訳すと「コメント求む」なのですが、
実際には各RFCの文書は公開される前に多くの議論を経た上で公開され、公開後に大きな修正は行われません。
そういう意味では、各ドキュメントは「コメント求む」という表現から想像するよりも
はるかに成熟したものです。

仮に改善の必要があった場合には、誤りについてはerrataとして公開されますが、
不足や根本的な改善については次のRFCを議論し、過去のRFCを打ち消す形で次に活かします。

HTTPの仕様を記述するRFCについて見ていきます。



=== HTTPのRFCと改定

HTTPも進化を伴いました。
執筆時点ではHTTPには0.9, 1.0, 1.1があります。
現在2.0の仕様策定中ですが、完成はしていません。

HTTP 0.9が極めてシンプルだったものであったのに対して、
HTTP 1.1の仕様にあたるRFC 2616では、
TXTファイルのページ数にして
実質176ページに渡る長大なものとなっています。

HTTP 1.1は1999年6月に公開されたRFC 2616ですが、
約15年経った今では様々な課題を抱えています。
特に当時は想定されていなかったWebブラウジング以外での
HTTPの利用が増えたことが大きいようです。

== HTTP 1.1 の新RFCについて

RFCは同じ分野で新しい仕様を必要とした場合、
過去のRFCをobsolete（廃止）扱いとすることで
新しい（番号の大きな方の）RFCを利用するよう促します。

2014年6月に、このHTTP 1.1の仕様が
15年ぶりに改定されました。現在ではその内容が
下記6つのRFCとして公開されています。

* RFC7230: Message Syntax and Routing
* RFC7231: Semantics and Content
* RFC7232: Conditional Requests
* RFC7233: Range Requests
* RFC7234: Caching
* RFC7235: Authentication

(TODO: 概要説明)

この改定では、HTTPのバージョンが増えたわけではありません。
HTTP 1.1と呼ぶとき、今後はRFC 2616ではなく上記のRFCのみを参照するようにしてください。
ちなみに、
RFC 7230に関わっているMark Nottingham氏は自身のブログ記事"RFC2616 is Dead"（RFC2616 は死んだ）
@<fn>{mark_nottingham}で、
「RFC2616は使わないでください。ハードドライブ、ブックマークから削除し、
印刷されているなら全て燃やしてしまうかリサイクルに回しましょう」とまで書いています。 
HTTP 1.1について深く調べる際には、RFCを参照することはもちろんですが、関連記事を読む際に、古いRFCを元にしていないかを気にするのは良いことでしょう。@<fn>{old_rfc_wont_fade}

//footnote[mark_nottingham][@<href>{https://www.mnot.net/blog/2014/06/07/rfc2616_is_dead}]

//footnote[old_rfc_want_fade][古いRFCを直接見ると、実はこのobsoleteとなったことに関する情報は記載されていません。これは利用者からみて少し面倒な事態を引き起こします。特にHTTP 1.1の古い側の仕様であるRFC 2616は現在でも公開されており、そこには、新しいRFC 7230〜7235を代わりに参照すべし、とは書いていません。一般的に公開されたRFC自体は一切修正されません。errataや別のRFCで上書きをするだけです。そのため、RFCを参照する側が情報収集を怠っていると、知らずのうちに古いRFCを参照する問題が発生します。さて執筆現在、Googleで「HTTP RFC」と検索します。すると、古い方のRFCが検索結果のトップとなります。長いこと参照されているのですから、ある意味当然です。しかし何も知らずにいると、それが実は参照してはいけないRFCだということに、気づくことがありません。他のWebサイトにおいてObsoleteとなったRFCは簡単に調べられますし、ニュースで取り上げられるケースもあります。単体のRFCを仕様書として絶対のものとは見ないようにしてください。]

=== HTTP 2.0 について

HTTP 2.0はHTTP 1.1の次バージョンとして標準化が行われている次のHTTP仕様です。
Googleが開発しているSPDFと呼ばれる仕組みを元にしています。

仕様策定としては最終段階にありますが、
「そもそもこれを公式の仕様とするべきではない」
と主張する人々もいます。


http://www.phoronix.com/scan.php?page=news_item&px=MTcwMTA

===[column] RFCへの「コメント」は誰でもできる

RFCが「仕様」ということで、
とても偉大で近づきがたい印象を持ってしまうこともあります。
筆者もその一人です。

ところで筆者は、あるRFCのワーキングループに積極的に参加したことがあります。
当時ある事情で特定のプロトコルを実装する必要があったのですが、
プロトコルに抜けがあって困っていました。
おそらく初期のバージョンでは検討から抜けていたのでしょう。

ちょうどその時、知り合いからそのプロトコルの次世代バージョンの
RFCが議論されていると聞き、個人のメールアドレスを使って
MLでの議論に参加することにしました。

変更としては非常にシンプルで説得力があったせいか、
特に何の異議もなく採用され、
RFCのAcknowledgementの項に名前が掲載されました。
こういうことは、普段ないだけに結構うれしいものです。

ここで大事なことは、
IETFでの議論は一般に広く開かれているということです。
迷惑と判断されるような行動をおこさなければ、
一介の技術者が世界的に使われる仕様に意見を出すことはいつでも可能です。

ただし、議論は英語です。


=== Android アプリからWebサーバからデータを取得する

実際にAndroid経由でHTTPアクセスをしてみましょう。
ここでは@<code>{java.net.HttpURLConnection}を用いることにします。

===[column] DefaultHttpClientとAndroidHttpClient について

HTTPアクセスを行うライブラリは他にも@<code>{org.apache.http.impl.client.DefaultHttpClient}や
@<code>{android.net.http.AndroidHttpClient}といったライブラリが紹介されることがあります。
しかし本稿ではそれらの理由はおすすめしません。
現時点でこれらの実装にはバグが多く、今後もメンテナンスされる見込みがないと考えられているためです。
なお、非常に古いAndroidのバージョン（2.2）では@<code>{java.net.HttpURLConnection}にバグがあったため、
それらの古いバージョンでは注意が必要です。

 * 参考: Android Apache HTTP Client と HttpURLConnection どっちを使うべき？ @<href>{http://y-anz-m.blogspot.jp/2011/10/androidapache-http-client.html}@<fn>{this_is_also_old_article}


//footnote[this_is_also_old_article][記事の公開2011年10月4日に公開された点も出来れば]



== UrlHttps を試す
== SSL

== 認証・認可について

 * 認証: 本人確認
 * 認可: アクセス許可

コンピュータの世界から離れて役所で公的な証明書を受け取ることを考えてみます。
例えば、戸籍。

申請書類を書いて、免許証と申請書類を提出し、
役所が大丈夫だと思えば、役所が持っている情報を提供してくれます。

免許証を見せることは自分が本人であることの確認です。
もし「自分である」ことがわかれば、方法は複数あります。


しかし、見せたからと言って、申請する書類の許可が常に得られるとは限りません。

== ぼこぼこぼこぼ

 * Authentication / Authorization
 * REST / RESTful
 * XML, JSONの概要
 * HttpURLConnection を試す


 * データを保存・共有するために必要
 * BaaS
 * Webブラウザから見える「独立のアプリケーション」
 * SaaS
 * AWS