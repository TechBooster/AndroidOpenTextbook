= Webサーバの基本

Android端末を有効活用する上では、インターネット、あるいはクラウド、そしてそこにあるサーバについて理解し、
それらと通信することが欠かせません。

これから、Webサーバと通信する際に役に立つ基礎知識を説明します。
Webサーバは「Web」と「サーバ」に分けられます。
本章ではまずその2つの用語について勉強しましょう。

== メモ

(この節は最終的には削除される)

=== 本章で取り上げないが依存しているもの

（他の章で紹介するかを確認する）

 * TCP/IPとネットワークスタックの概念
 * WebViewの使い方

== Webって何
=== 最初のWeb

webという英単語は、もともと「蜘蛛の巣」を意味しています。

この用語に絡めて、1990年にスイスのCERNという研究所に所属していた
Tim Berners-Lee博士がWorldWideWebを提唱したのがこの言葉の始まりです。@<fn>{internet_existed_before_www}
博士は世界に分散した情報（特に当初は技術論文）を皆が共有して相互に閲覧できるよう、
文書内のリンクを介してインターネットに接続された世界中の情報が、蜘蛛の巣のように密につながり、
情報を共有出来る状態になる未来を期待し、どのような要素が必要か、といった点について、世界に対する提案書を公開しました。@<fn>{www_proposal}
このあと"Mosaic"と呼ばれるWebブラウザの登場もあって、Webの利用は爆発的に普及し、今に至ります。

//footnote[internet_existed_before_www][情報共有を行う手段自体は1990年以前から存在しました。例えばWikipediaの「電子メール」の記事によれば1965年に世界最初の電子メールが使われ始めた、とあります。]
//footnote[www_proposal][最初の提案をW3C（The World Wide Web Consotium）のWebサイト@<href>{http://www.w3.org/Proposal.html}で読むことが出来ます。ブログやTwitterどころかWebページという概念が一般に存在しない時代のことです。]

初期のWebでは、相互にリンクのある「ハイパーテキスト」をWebサーバに配置し、それを人がWebブラウザで見るという用途が一般的でした。
HTML（Hyper Text Markup Language）は、その名前が示す通り「ハイパーテキスト」ためのマークアップ言語@<fn>{markup_language}です。
また、世界中に散らばったハイパーテキストがどこにあるかを「ハイパーテキスト」（HTML）に記述できなければなりません。
というわけで、Webの世界ではURI（Universal Resource Identifier）が大変重要です。
Webを理解する上で、HTTPとURIはまず最重要の技術と言えます。

//footnote[markup_language][マークアップ言語は「文章の構造（段落など）や見栄え（フォントサイズなど）に関する指定を文章とともにテキストファイルに記述するための言語」です。（Wikipedia日本語記事より）有名なものとしてHTMLがあります！]

=== 進化し続けるWeb

現在のWebは、WebブラウザによるWebサイト閲覧にとどまらない幅広い用途に使われています。
『Webを支える技術』では、現在のWebの用途を大きく分けて3つに分けて考えています。

 * Webサイト
 * ユーザインターフェースとしてのWeb@<fn>{web_as_ui}
 * プログラム用APIとしてのWeb

//footnote[web_as_ui][家庭用ルータの設定画面やHTMLヘルプ等を「Webサイト」と分けています。Webサーバを介した用途異なるというという意味で、そのとおりです。]

見方を変えてAndroidアプリの観点からは、以下の様になるでしょう

 * 外部WebサーバにHTMLを取得し、WebView（もしくはWebブラウザ）で表示する
 * 端末（アプリ）に保存されたHTMLをWebView（もしくはWebブラウザ）で表示する
 * WebサーバからXMLやJSONを取得し、アプリで利用する

さてこの3つの用途の中で「Webサーバ」が絡むのは1番目と3番目です。
両方共、Android端末からWebサーバへデータを取りに行きます。
その「逆」はあまり発生しません。

== サーバ
=== クライアント・サーバモデル

用途はどうであれ、Webにおいては、WebブラウザやAndroidアプリからWebサーバへWebページなどを「リクエスト」します。
逆に、WebサーバがAndroid端末に接続してくるということはありません。

このような場合、データを要求する側であるAndroid端末はクライアント、Webサーバはその名前にあるとおりサーバと呼ばれます。
「クライアント・サーバモデル」という、インターネット・クラウドで非常に一般的なモデル（考え方）です。

別のモデル（考え方）にP2Pというものがあります。
データを要求する側と提供する側が柔軟に入れ替わるため、どちらがサーバともクライアントとも言えないような通信の仕方をします。

例えばインターネット電話アプリSkypeでは相手と通話する際にはどちらからどちらに繋げる（リクエストを投げる）こともできますから、
どちらがサーバともクライアントとも言えない、という意味でクライアント・サーバモデルではないと考えます。

いわゆる「分散ファイル共有ソフト」もしばしばP2Pの例として挙げられます。

サーバという言葉は、英語で言えばserverです。
日本語でも、例えば「ジュースサーバ」「ビールサーバ」といった表現で登場します。
@<fn>{server}

//image[juiceserver][ジュースサーバー]{
//}

「ジュースサーバ」は相手にジュースを提供します。
Webサーバは、例えばWebページのようなインターネット・クラウド上にある情報を提供するために存在します。

//footnote[server][英語名詞であるserverに対応する動詞（「〜する」）はserveです。これは「〜に仕える」「〜のために働く」という意味です。serverのコンピュータ関連の用語ではない本来の意味は「給仕人」「接客係」です。ちなみに給仕の読みは「きゅうじ」であって「きゅうし」ではありません。]


WebブラウザやAndroid端末は、Webサーバから見て「クライアント」です。

通常のAndroidアプリを作る限り、「Webサーバから見てAndroid端末やアプリがクライアントである」と考えてしまって構いません。
@<fn>{android_maybe_server}

//footnote[android_maybe_server][Webサーバからちょっと離れて、複数のAndroid端末間でWiFi経由で対戦ゲームを行うケースを考えましょう。このとき、多くのAndroid端末はクライアントですが、どれか一つはサーバになり、その他の端末からの接続を待つのが一般的です。具体的にはまず、サーバ側がゲームを行うための「部屋」を作り、その他の端末の接続を待ちます。その他の端末はしばしば「ホスト」とも呼ばれるそのサーバへクライアントとして接続します。全員が揃った段階で、ゲームを開始します。このとき、サーバもしくは「ホスト」の役割は別の端末が行うこともありえます。このとき、その別の端末が今度はサーバで、さきほどサーバだった端末はクライアントとなります。]

クライアントであるAndroid端末は、
例えばWebブラウザを経由してWebサーバに情報を取りにいきます。
この場合、ざっくりと言えば

 * Android端末はクライアントとしてサーバにデータを取りに行く
 * サーバはクライアントの要求を受け取り、要求に見合ったデータを返す

という作業が発生します。

== プロトコル
=== 相手がいるからにはルールが必要

相手がいなければ自分でルールを決めてしまえば世話がありません。
ルールを途中で変えても、自分がそれを守れば良いので、大して問題ではありません。

しかしWebでは、世界中に分散しているサーバ、人々と通信します。
「ネットワーク」の章でも学んだ通り、
相手がいる場合には何らかのルール、つまり「プロトコル」(protocol)が必要です。
@<fn>{about_protocol}

//footnote[about_protocol][インターネットに関する技術的な話を除くと、国家間の外交に関するニュース等で「プロトコル」という言葉を散見する印象を筆者は持ちます。その場合は「外交儀礼」という意味で、例えば他国の王族をもてなす際には一定の手順、すなわちプロトコルを踏まえるのがならわしです。破ると、場合によっては外交問題になります。]

特にコンピュータは、人間以上にアドリブに大変弱いです。
サーバとクライアントのやりとりでは、想定外の事態を含めていろいろな状況が起こりえますから、
その状況を可能な限り網羅したプロトコル（つまりルール）を全て準備しておき、
クライアントとサーバの両方がそのプロトコルにしたがってデータを要求してデータを受け取る必要があります。

=== スーパーに梅干しの在庫を問い合わせる

プロトコルについ考えるため、
例としてスーパー「なるえつ」に大山の梅干しの在庫があるかを確認するために携帯電話から電話をかけたとしましょう。

通話して相手につながりました。
さてそこで、相手が
"Hello, this is Mike. How can I help you?"
と言ってきたとします。
日本語での応答を期待していたとすると、これは困ります。
@<fn>{mike_is_kind}

//footnote[mike_is_kind][日本語で言うと「私はマイクです。何かお手伝いできることはありますか」と言っています。2文目は英語の顧客サポートでしばしば聞く表現で、つまり、多分ですが、この窓口は接客のための窓口で、マイクは、可能性として、なるえつのサポートかもしれません。でも店名言ってません。というわけで筆者なら"Well, am I speaking to Naruetsu Supermarket?"とか聞くような気がしますが、やっぱり勘弁です。]

日本語でスーパーに対して大山の梅干しを問い合わせる場合、
大まかに以下のような流れになるでしょう。

 * 「はい、スーパーなるえつです」
 * 「名前も名乗らぬ客です。大山の梅干しはありますか」
 * 「少々お待ちください……在庫ありました」
 * 「ありがとうございますガチャっ」

ラフに書けばこのくらいの応答がありえます。

インターネット上でもこのやりとりと似たことが行われています。
まず冒頭のサーバ側の返答で、クライアントは少なくとも相手が「スーパーなるえつ」と名乗っていることを理解します。
@<fn>{certificate_for_naruetsu}

//footnote[certificate_for_naruetsu][厳密にはスーパーなるえつであるかの証明書が欲しいところです]

次に客は「私は認証されていないユーザです」と延べ、後述するHTPのGETかHEADに相当する形で「大山の梅干し」の在庫確認のクエリを送っています。
「少々お待ちください」はおいとくとして、少なくともその要求に対してリソースがあることまではスーパーなるえつサーバは応答します。

残念ながらインターネットのようにデータを直接受け取ることはできないので、
ここで電話のやりとりは終わりにして、実際に店舗に行った時に売り切れている恐怖と戦います。

=== TCP/IPとHTTPの境界

なるえつと梅干しの例では最初、電話の受け取り側（サーバーです！）は電話の応答口が「スーパーなるえつ」であると言っています。

ここで突然
「今朝、丸ノ内線で、すずらんの花が咲きました」
と語られるのは困ります。歌を歌われたらもっと困ります。

「電話がつながる」ことと「必要な情報を得られる」ことの間にはまだ隔たりがあるわけです。

「電話がつながる」ところまでが、言ってみればTCP/IPが保証している領域、
と考えるのが今はわかりやすいと思います。
「TCP/IP」といったプロトコルだけでは、Webサーバ上のデータをやりとりするのには不足です。
電話がつながっても、日本語である必要があるし、
日本語にしても適切な応対の幅があるというのもわかります（梅干しがなければ「ない」と答えます。）@<fn>{osi}

//footnote[osi][TCP/IPについて本当に前章で説明されているのか知らずに書いてますが、ついでに「OSI参照モデル」という言葉も紹介しておきます。なるえつの例で重要な点は「電話」と「その上でなされる会話」は別のレイヤ（層）に分けて考えることができる、ということです（在庫確認は電話でなくても出来ますね。）つきつめていくと、インターネット上でのやりとりは「7つの層」で説明できると考えるのがOSI参照モデルです。ぐぐるといっぱい出てきますので、このあたりの説明は、これで。]

== HTTP

Webサーバの場合にTCP/IPの上で使われるのは、
HTTP（Hypertext Transfer Protocol）というプロトコルです。

このプロトコルの詳細はRFCと呼ばれる仕様書により定義されます。

RFCはRequest For Commentsの略です。
IETF（Internet Engineering Task Force）と呼ばれる
組織によって発行される、技術仕様等に関する文書を指します。
IETFは特にインターネットで利用される標準について議論を行う組織です。
議論する対象に応じてワーキンググループを作成し、
メーリングリストでの議論の後、RFCを発行するなどして
そのワーキンググループの活動を一旦終了します。
TCP/IPに関わる仕様もIETF由来です。

RFCの詳細については本章ではここまでにしておきます。

=== HTTP、基本のリクエストは「GET」と「POST」

Webサーバとやりとりする基本的なプロトコルであるHTTPでは、
クライアントからサーバへ要求（リクエスト、request）を送り、
サーバがそれに対する応答（レスポンス、response）を返します。

リクエストの種類について、HTTPにはたくさんの種類がありますが、
まず最初に学ぶべきは「GET」リクエストと「POST」リクエストです。

==== GETリクエスト

==== POSTリクエスト


==== レスポンスコード

HTTPにおいて、Android端末のようなクライアントから
リクエストを送った際、サーバはその要求に対して様々な返答を返します。

非常に典型的なのは「このWebページですね。どうぞ」と
「そんなWebページ、ない」という2種類の応答です。

Webサーバのそれぞれのレスポンスに対しては3桁の数字が割り振られます。
それぞれ、3桁目が主要な理由を示しており、残りの2桁でより具体的になります。

上の例で言えば「このWebページですね、どうぞ」は200番「OK」です。
「そんなWebページ、ない」は404番です。
これらの意味は皆RFCに記載されています。

本章では立ち入りませんが、レスポンスコードはプロトコルで規定されていつつも、
歴史上の理由でしばしば仕様通りに返答を返してくれないWebサーバもあります。
ここでは「仕様無視！そういうのもあるのか」という程度で軽く理解しておくことにしましょう。

=== 演習: Android アプリからWebサーバにアクセスしてみよう

さて、ここでは実際にAndroid経由でHTTPアクセスをしてみましょう。
ここでは@<code>{java.net.HttpURLConnection}を用いることにします。

TODO: ネットワークの章でやってる可能性が高い。

===[column] DefaultHttpClientとAndroidHttpClient について

HTTPアクセスを行うライブラリは他にも@<code>{org.apache.http.impl.client.DefaultHttpClient}や
@<code>{android.net.http.AndroidHttpClient}といったライブラリが紹介されることがあります。
しかし本稿ではそれらの理由はおすすめしません。
現時点でこれらの実装にはバグが多く、今後もメンテナンスされる見込みがないと考えられているためです。
なお、非常に古いAndroidのバージョン（2.2）では@<code>{java.net.HttpURLConnection}にバグがあったため、
それらの古いバージョンでは注意が必要です。

 * 参考: Android Apache HTTP Client と HttpURLConnection どっちを使うべき？ @<href>{http://y-anz-m.blogspot.jp/2011/10/androidapache-http-client.html}@<fn>{this_is_also_old_article}

//footnote[this_is_also_old_article][記事の公開2011年10月4日に公開された点も出来れば]



=== ステートレスなHTTPとCookie

HTTPは「ステートレスなプロトコル」と言われます。
HTTPの仕様の中には「前回の状態をサーバやクライアントは覚えておいてね♪」と要求している項目がないという意味です。

ハンバーガ屋の例がしばしばでるのでここでもハンバーガ屋を考えましょう。
ハンバーガ屋に行き「ツケといてくれ、旦那」と客が支払いを後回しにもできるのがステートフルです。
この場合、次に行った時「この前のツケ、払ってくださいよ」と言うことができるように、
ツケという状態をハンバーガ屋が覚えておけるのが、ステートフルの一見したところ良い点です。
しかし、江戸時代からある下町のハンバーガ屋がお得意客数名に対してこれを行えても、最近の全国チェーンでこれは無理と言えます。
というよりも全国チェーンでは「40分後に取りに来ますのでその時に出して」だって、割と断られます。
非常にたくさんのお客を相手にうまくサービスを行き渡らせるには、客は逃げ出さない前提でその場で払ってその場でものをもらうのが通例です。
つまり、自動販売機のように前のことを何も覚えていないのがステートレスです。@<fn>{stateful_burger}

//footnote[stateful_burger][ちなみにこの無理矢理な例で言うと、番号札を渡して店員が後から席に持っていくモデルは、十分ステートフルなサーバです。しかし秒間1万リクエストくらい来る先進的なハンバーガ屋だとこれすら無理です。ステートレス・バーガーが素晴らしいわけです]

しかし実際にWebサーバを介してアクセスすると、
多くのWebサービスでは、ユーザ名とパスワードなど、いろいろなものをWebサーバが記憶しているように見えます。
特に、ブラウザを閉じてもそれらが残っているのは驚きです。

この大方の欲求に対処するのがCookieと呼ばれる仕組みです。
RFC 6265が参照できる仕様ですが、歴史的事情で完全にこのRFCの通りには動作しないとのことです。
@<fn>{rfc6265}

//footnote[rfc6265][Webではしばしばこういう話があります。次の章でもっと生々しい話をご紹介します。]

== HTML, URI

== REST
=== XML, JSON

HTTPにはWebサーバがどのようなタイプのデータを返すかを示す
Content-Type と呼ばれる情報を返します。

WebブラウザでWebページを見る場合、多くの場合HTMLが返されます。
しかしAndroid端末が情報を取得するばあい、
人が見るために整形されたHTMLを取得するのは冗長です。

そのため、機械が読み取りやすいデータ形式として、
しばしばXMLとJSONという形式を見ることになるでしょう。

=== 実習: 天気の情報を取ってくる

== SSL接続
=== UrlHttps を試す

== 認証・認可

 * 認証: 本人確認
 * 認可: アクセス許可

コンピュータの世界から離れて役所で公的な証明書を受け取ることを考えてみます。
例えば、戸籍。

申請書類を書いて、免許証と申請書類を提出し、
役所が大丈夫だと思えば、役所が持っている情報を提供してくれます。

免許証を見せることは自分が本人であることの確認です。
もし「自分である」ことがわかれば、方法は複数あります。

しかし、見せたからと言って、申請する書類の許可が常に得られるとは限りません。
あなたが誰であるか、とその人に何かを行う許可を与えることは別のことです。



== その他のサーバ

本章を始めとする一連の説明は、Webサーバについての説明を中心としています。
しかしインターネット・クラウド上にあるサーバはそれだけにとどまりません。

 * メールサーバ
 * ファイルサーバ
 * プリントサーバ

「プリントサーバ」について補足しましょう。

Word文書を印刷したりするために、プリンタを利用することは多いと思います。
昔のプリンタはUSB接続やその他の接続でPC1台とつながりませんでした。
しかし業務用プリンタや最近のプリンタは賢く、
複数台のパソコンやAndroid端末などから「このデータを印刷して」という要求を受けて、印刷を行います。
リクエストを受けて、レスポンスとして印刷するので、これもサーバです。

Webサーバと通信するためにプロトコルとして「HTTP」が重要でした。
同様に、各サーバではその用途に応じてプロトコルが必要です。

 * メールサーバ ... POP, IMAP, SMTPなど
 * プリントサーバ ... IPP, LPRなど
 * ファイルサーバ ... SMBなど

全てではありませんが、これらのプロトコルの多くも仕様、特にRFCで規定されたりします。@<fn>{not_rfc}

//footnote[not_rfc][インターネット上で利用されるプロトコルの全ての仕様が完全に公開されるとは限りません。通信する相手同士が合意するためのルールがプロトコルですから、合意が秘密裏に行われていても動作すればその二者（二社）にとっては十分と言えます。その場合はそれを知らない人が参加できないので、「ケチ」とか「いじわる」とか言われますが、合意の難易度は場合によっては飛躍的に下がることもあります。この点については次章でもう少し考えます]

== まとめ

本章ではWebサーバと通信する上で必要な基礎知識について説明しました