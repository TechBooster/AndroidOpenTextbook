= Webサーバ

Android端末を有効活用する上では、インターネット、あるいはクラウド、そしてそこにあるサーバについて理解し、それらと通信することが欠かせません。

本章では、Webサーバと通信する際に役に立つ基礎知識を説明します。
各技術の詳細については深追いしませんが、読者がWebサーバの周辺技術への理解を深める上で参考になる文献を最後に紹介します。

== メモ

(この節は最終的には削除される)

=== 本章で取り上げないが依存しているもの

（他の章で紹介するかを確認する）

 * TCP/IPとネットワークスタックの概念
 * WebViewの使い方
 * SSL

=== 関連情報

最後の節で取り上げるかまだ決めてないもの、もしくは勉強しておくべきこと。

 * 『コンピュータネットワーク 第5版』
  * タネンバウム博士によるネットワークの教科書です。第7章 アプリケーション層の説明の一つとしてWorld Wide Webの説明と、第8章のネットワーク・セキュリティが読者の興味を引くかも知れません。どちらかというと「ネットワーク」の章の参考書籍と言えるかもしれません :-P
 * http://www.html5rocks.com/ja/tutorials/internals/howbrowserswork/
  * ブラウザ側。
 * 『過負荷に耐えるWebの作り方』
  * 第一回AKB総選挙のWebサーバがどう作られたかが書かれた本です。高負荷なWebサーバの構成やテスト方法等が書かれており、端末側から見えない部分の概要を知りたい方には中々良い本です。
@<fn>{akb_math}

//footnote[akb_math][個人的に超知りたいのは、投票権で使われたというシリアル番号生成アルゴリズムですが、そこは書いてないんですよね]


== Web概略
=== Webって何なの

webという英語はもともと「蜘蛛の巣」を意味しています。
この用語に絡めて、1990年にスイスのCERNという研究所に所属していた
Tim Berners-Lee博士がWorldWideWebを提唱したのが始まりです。@<fn>{internet_existed_before_www}
博士は世界に分散した情報を皆が共有できるよう、
文書内のリンクを介して世界中の情報が蜘蛛の巣のように相互につながり、情報を共有出来る状態になることを期待したのでした。@<fn>{www_proposal}

//footnote[internet_existed_before_www][情報共有を行う手段自体は1990年以前から存在しました。例えば電子メールはWikipediaの「電子メール」の記事によれば1965年に世界最初の電子メールが使われ始めた、とあります。]
//footnote[www_proposal][提案書はW3C（The World Wide Web Consotium）のWebサイト@<href>{http://www.w3.org/Proposal.html}で読むことが出来ます。]

このあと世界初のWebブラウザである"Mosaic"の登場とあいまって、Webの利用は爆発的に普及したと言われています。
@<fn>{web_server}

//footnote[web_server][Webサーバ（もしくはWeb Server）という表現自体をTim博士が提案で使っていたのかと思ったのですが、正確には使っていないようです。氏はWorldWideWebに必要な構成要素（Building blocks）としてbrowserとserverを挙げていますがweb serverという表現はありません。いや、何が疑問かってなんで俺らはWorldWideWebサーバって言わないのかなぁと思ったのですね。あまり正確な説明ができそうもないので筆者の見解を述べておくと、WorldWideWebというのは世界全体を蜘蛛の巣のように一つのwebとしてとりまとめる概念で、あくまで見えているのは一つのwebなんだろうと。で、その中のノードの一つとしてのサーバだからWebサーバなんだろうなぁと思ったのです。でもなんで世の中のURLはじゃぁweb.amazon.co.jpとかじゃなくてwww.amazon.co.jpなんでしょうね。別にそんな細かいことどうでもいいですね。]

Webは、相互にリンクのある「ハイパーテキスト」をWebサーバに配置し、それをWebブラウザで見るという用途を前提としていました。
HTML（Hyper Text Markup Language）はそのためのマークアップ言語です。
また、世界中に散らばったハイパーテキストがどこにあるかを「ハイパーテキスト」（HTML）に記述できなければなりません。
というわけで、Webの世界ではURI（Universal Resource Identifier）が大変重要です。

==== URI, URL, URN

URL（Universal Resource Locator）という表現の方を多く見るかもしれません。
ただし、現在、WebサーバーやHTTPの仕様上で使われるのはURIの方です。

歴史的にはURLという概念が先に登場しました。
1999年に発行されたHTTP 1.1の古い側の仕様にあたるRFC 2616でもURLという表現が使われています。

しかし2000年代までに行われた議論によって、
世界全体でのリソースの識別にLocation（位置）だけでなくName（名前）
導入するべきではないか、という流れになったようです。
その際、URLという概念に加えてURN（Universal Resource Name）も追加され、
それらをまとめる形としてURIという表現が生まれました。
なお、議論のさなかには他にもURIに含まれるべきものがあるといった意見もあったようです。
URIについてはRFC 3305に詳細な説明があります。

HTTP 1.1の新しい方の仕様であるRFC 7230〜7239では一律にURIを使用しています。

お話を進める前に、馴染みが薄いと思われるURNについて説明しましょう。

例えば本のISBN番号を表現するために"urn:isbn:4844335340"というURNを用いることができます。
このURNによって、某社の某書籍の存在を曖昧さなしに表現できます。

ただし、これではWeb上のどこにその本の情報があるか、どこで購入できるか、といった場所についての情報は含まれません。
Web上の場所を指す場合にはここでURLに相当するURIを使用します。
urn:isbn:4844335340 をAmazon上で見るには@<href>{http://www.amazon.co.jp/dp/4844335340}をどうぞ、といった説明ができます。

URNは登録制なので勝手に使用はできません。
ISBNとurnの対応は予めそのような取り決めがなされているために成立します。
そのため一般の人が自分の持つリソースのために使うにはURL（相当のURI）と比べると大変敷居が高い、といえると思います。

ただ、一度登録されたものについてはそれがなんであるかが曖昧さなしに決まるという特長は技術的にしばしば役に立ちます。
特に技術上曖昧さを排したい仕様名や仕様の中の概念に使われるケースを見ることが多いと思われます。

RFCという言葉について考えてみましょう。例えば、RFC1458という文字列からはRequest For Commentsの1458番という文書のことだと予想が一応立ちます。
しかし実はラジオ福島のことかもしれません。蛇足になりますが@<href>{http://www.ustream.tv/user/rfc1458}というURIは存在し、どうやらこれはラジオ福島のユーザアカウント情報を表示するWebページを参照できます。
要は「RFC1458」では一意とは言い切れません。
urn:ietf:rfc:1458であれば絶対にラジオ福島の方を差しません。

URNは古い用法としての「URL」としての役割を果たすわけではなく、場所がわからないのでHTMLのhrefとして記述してもWebブラウザは多分どこにも移動してくれません。
URIということで<a href="urn:ietf:rfc:1458">RFC 1458</a>と書いてもこのリンクはWebブラウザ上では意味がないでしょう。

厳密には全てURIで統一するのが適切です。
しかし今でもURLという表現がWebサーバやその周辺実装に使われており、
この2つの混同は大抵の場合あまり問題にならないようにも見えます。

Javaのライブラリでも、特にJavaの初期に実装されたものにはURLという名前のものが多く見られます。
後述する@<code>{java.net.HttpURLConnection}もURLと名前についています。

古くから使われるライブラリや古い仕様ではこのあたりの区別は曖昧であるため、
読者はURLとURIの違いについて知りつつ、
相手側がその用法について混乱している場合には本来の意図を問うのが優れていると、本章筆者は考えます。

==== Bonus!! JavaのURLクラスとURIクラス

Javaには両方のクラスがありますね！

ここで筆者としては紹介せずにいられないJava Puzzleがあります。

http://youtu.be/wDN_EYUvUq0?t=9m50s

相当古い動画なのですが、仕様上今でも問題になるURLクラスとURIクラスのSet内挙動が異なる点を
指摘した例として、当時新入社員だった筆者としても大変驚いた記憶があります。
この挙動の違いは本章のWebサーバの議論とはあまり関係はなく、

調べたところ、URLクラスはJDK1.0、URIクラスは1.4の導入とのことです。

どちらかというと初期のJavaのライブラリ設計の失敗に関わるものですが、
「古い」というのはしばしばそういう問題も引き起こす、ということで一つ。


=== 進化するWeb


『Webを支える技術』では、現在のWebの用途を大きく分けて3つに分けて考えています。

 * Webサイト
 * ユーザインターフェースとしてのWeb@<fn>{web_as_ui}
 * プログラム用APIとしてのWeb

//footnote[web_as_ui][家庭用ルータの設定画面やHTMLヘルプ等を「Webサイト」と分けて並べています]

Androidアプリの観点からは以下の様になるでしょう

 * 外部WebサーバにHTMLを取得し、WebView（もしくはWebブラウザ）で表示する
 * 端末（アプリ）に保存されたHTMLをWebView（もしくはWebブラウザ）で表示する
 * WebサーバからXMLやJSONを取得し、アプリで利用する



=== クライアント・サーバモデル

「Webサーバ」が絡むのは1番目と3番目です。
両方共、Android端末からWebサーバへデータを取りに行きます。

その「逆」はあまり発生しません。
つまり、WebサーバがAndroid端末にデータを要求するために
端末に接続してくるということはWebサーバという範囲ではありません。

こういう場合、データを要求する側であるAndroid端末はクライアント、
Webサーバはその名前にあるとおりサーバと呼ばれます。
「クライアント・サーバモデル」という、
インターネット・クラウドで非常に一般的なモデル（考え方）です。@<fn>{p2p}

//footnote[p2p][別のモデル（考え方）にP2Pというものがあります。データを要求する側と提供する側が柔軟に入れ替わるため、どちらがサーバともクライアントとも言えないような通信の仕方をします。例えばインターネット電話アプリSkypeでは相手と通話する際にはどちらからどちらに繋げる（リクエストを投げる）こともできますから、どちらがサーバともクライアントとも言えない、という意味でクライアント・サーバモデルではないと考えます。いわゆる「分散ファイル共有ソフト」もしばしばP2Pの例として挙げられます。]

サーバという言葉は、英語で言えばserverです。
日本語でも、例えば「ジュースサーバ」「ビールサーバ」といった表現で登場します。
@<fn>{server}

//image[juiceserver][ジュースサーバー]{
//}

「ジュースサーバ」は相手にジュースを提供します。
Webサーバは、例えばWebページのような
インターネット・クラウド上にある情報を提供するために存在します。

//footnote[server][英語名詞であるserverに対応する動詞（「〜する」）はserveです。これは「〜に仕える」「〜のために働く」という意味です。serverのコンピュータ関連の用語ではない本来の意味は「給仕人」「接客係」です。ちなみに給仕の読みは「きゅうじ」であって「きゅうし」ではありません。]

サーバに要求を伝える側を「クライアント」と呼びます。
@<fn>{about_client}
WebブラウザはWebサーバから見てクライアントです。
「Webサーバから見てAndroid端末がクライアントであると」考えてしまっても構いません。
@<fn>{android_maybe_server1}
@<fn>{android_maybe_server2}

//footnote[about_client][日本語でも、お客さんを「クライント」と呼ぶ職業があります。英語でclientです。]
//footnote[android_maybe_server1][本章の範囲ではまず問題ありませんが、Android端末が「常に」クライアントである、と考えるのは間違いです。Andorid端末でもサーバになることはしばしば起こります。実際、Android端末自身をWebサーバにするアプリが存在しますし、簡単なものを実装することは読者の方にも可能です。ただし、全世界にデータを公開する類のWebサーバの役割をするのは難しいです。]
//footnote[android_maybe_server2][クライアントとサーバという表現は、通信を行う場合の「役割」であって、場合によってはこの「役割」が逆転することはありえます。Webサーバからちょっと離れて、複数のAndroid端末間でWiFi経由で対戦ゲームを行うケースを考えましょう。このとき、多くのAndroid端末はクライアントですが、どれか一つはサーバになり、その他の端末からの接続を待つのが一般的です。具体的にはまず、サーバ側がゲームを行うための「部屋」を作り、その他の端末の接続を待ちます。その他の端末はしばしば「ホスト」とも呼ばれるそのサーバへクライアントとして接続します。全員が揃った段階で、ゲームを開始します。このとき、サーバもしくは「ホスト」の役割は別の端末が行うこともありえます。このとき、その別の端末が今度はサーバで、さきほどサーバだった端末はクライアントとなります。]

クライアントであるAndroid端末は、
例えばWebブラウザを経由してWebサーバに情報を取りにいきます。
この場合、ざっくりと言えば

 * Android端末はクライアントとしてサーバにデータを取りに行く
 * サーバはクライアントの要求を受け取り、要求に見合ったデータを返す

という作業が発生します。


== プロトコルって何
=== 相手がいるからにはルールが必要

Androidアプリを作っている際、
Webサーバのような外部の世界と通信しない場合、


「クライアントはデータをサーバに取りに行き、
サーバはデータをクライアントに送る」のですが、
では「具体的にどうやって」行うのでしょうか。

「ネットワーク」の章でも学んだ通り、
相手がいる場合には何らかのルールが必要です。
これを「プロトコル」(protocol)と言います。
@<fn>{about_protocol}

//footnote[about_protocol][プロトコルという表現は日常生活ではあまり見ない印象です。ただ、インターネットに関する技術的な話を除くと、国家間の外交に関するニュース等でこの言葉を散見する印象を筆者は持ちます。その場合は「外交儀礼」という意味で、例えば他国の王族をもてなす際には一定の手順、すなわちプロトコルを踏まえるのがならわしです。破ると、ヘタすると外交問題になります。]

特にコンピュータは、基本的にはアドリブに大変弱いです。
サーバとクライアントという二者のやりとりでは
トラブル含めていろいろな状況が起こりえますが、
その状況を可能な限り網羅したプロトコル（つまりルール）
を準備しておき、クライアントとサーバの両方が
その振る舞いにしたがってデータを要求して
データを受け取る必要があります。

「ネットワーク」の章で説明される「TCP/IP」といった
プロトコルだけでは、Webサーバ上のデータを
やりとりするのには不足です。

=== 大山の梅干しを問い合わせる

例えば、近所のスーパー「なるえつ」に
大山の梅干しの在庫があるかを確認するために、
携帯電話から電話をかけたとしましょう。

通話して相手につながりました。
さてそこで、相手が
"Hello, this is Mike. How can I help you?"
と言ってきたとします。
日本語での応答を期待していたとすると、これは困ります。
@<fn>{mike_is_kind}

//footnote[mike_is_kind][日本語で言うと「私はマイクです。何かお手伝いできることはありますか」と言っています。2文目は英語の顧客サポートでしばしば聞く表現で、つまり、多分ですが、この窓口は接客のための窓口で、マイクは、可能性として、なるえつのサポートかもしれません。でも店名言ってません。というわけで筆者なら"Well, am I speaking to Naruetsu Supermarket?"とか聞くような気がしますが、やっぱり勘弁です。]

日本語でスーパーに対して大山の梅干しを問い合わせる場合、
大まかに以下のような流れになるでしょう。

 * 「はい、スーパーなるえつです」
 * 「名前も名乗らぬ客です。大山の梅干しはありますか」
 * 「少々お待ちください……在庫ありました」
 * 「ありがとうございますガチャっ」

ラフに書けばこのくらいの応答がありえます。@<fn>{maniac_explanation}

//footnote[maniac_explanation][厳密ではありませんが、インターネット上でもこのやりとりと似たことが行われています。まず冒頭のサーバ側の返答で、クライアントは少なくとも相手が「スーパーなるえつ」と名乗っていることを理解します。厳密にはスーパーなるえつであるかの証明書が欲しいところですが。次に客は「私は認証されていないユーザです」と延べ、後述するHTPのGETもしくはOPTION要求に相当する形で「大山の梅干し」の在庫確認のクエリを送っています。HTTPで規定がない「少々お待ちください」は曲者ですがおいとくとして、少なくともその要求に対してリソースがあることまではスーパーなるえつサーバは応答します。残念ながらインターネットのようにデータを直接受け取ることはできないので、ここで電話のやりとりは終わりにして、実際に店舗に行った時に売り切れている恐怖と戦います（とりおきプロトコルについては省略）。ちなみにHTTPには「ありがとうございます」を伝えるプロトコルはありません。冗長ですが、ここでお礼も言わずにガチャッてのは現実世界ではあまりやってはいけませんね。]

最初の相手側（サーバーです！）は
電話の応答口が「スーパーなるえつ」
であると言っています。

ここで突然
「今朝、丸ノ内線で、すずらんの花が咲きました」
と語られるのは困ります。

非常に適当な例で恐縮ですが、
「電話がつながる」ことと
「必要な情報を得られる」ことの間には
まだ隔たりがあることがわかります。

クライアントとサーバの話に戻りますと、
「電話がつながる」ところまでが、
言ってみればTCP/IPが保証している領域、
と考えるのが今はわかりやすいと思います。
電話がつながっても、日本語である必要があるし、
日本語にしても適切な応対の幅があるというのもわかります。



=== Webサーバが従うプロトコル HTTP

一般的な社会でも、ルールはみんなで決めますし、
決まったものは守ります。

Webサーバの場合に使われるのは、
HTTP（Hypertext Transfer Protocol）
というプロトコルです。
このプロトコルの詳細はRFCと呼ばれる文書により定義されます。

=== RFCとは

RFCはRequest For Commentsの略です。
IETF（Internet Engineering Task Force）と呼ばれる
組織によって発行される、技術仕様等に関する文書を指します。
IETFは特にインターネットで利用される標準について議論を行う組織です。
議論する対象に応じてワーキンググループを作成し、
メーリングリストでの議論の後、RFCを発行するなどして
そのワーキンググループの活動を一旦終了します。
TCP/IPに関わる仕様もIETF由来です。

RFCと呼ばれるドキュメントはたくさんあり、それぞれに連番がふられています。
「RFC」のあとに数字をつけ、例えば「RFC 7230」といった形で
特定のRFCを参照します。@<fn>{many_rfc}

//footnote[many_rfc][現時点でも7000を越えるRFC文書があるのは事実ですが、全部がインターネットで活用されている、というわけではありません。特にエイプリルフールに発行されるRFCの中には完全にジョークのものがあります。1998年に公開されたRFC 2324の"Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)"などはわかりやすい一例です。同RFCの2.3.2 "418 I'm a teapot"は私が学生時代にも衝撃を受けた記憶があります。]

Request For Commentsは日本語に訳すと「コメント求む」なのですが、
実際には各RFCの文書は公開される前に多くの議論を経た上で公開され、公開後に大きな修正は行われません。
そういう意味では、各ドキュメントは「コメント求む」という表現から想像するよりも
はるかに成熟したものです。

仮に改善の必要があった場合には、誤りについてはerrataとして公開されますが、
不足や根本的な改善については次のRFCを議論し、過去のRFCを打ち消す形で次に活かします。

HTTPの仕様を記述するRFCについて見ていきます。

=== HTTPのRFCと改定

HTTPも進化を伴いました。
執筆時点ではHTTPには0.9, 1.0, 1.1があります。
現在2.0の仕様策定中ですが、完成はしていません。

HTTP 0.9が極めてシンプルだったものであったのに対して、
HTTP 1.1の仕様にあたるRFC 2616では、
TXTファイルのページ数にして
実質176ページに渡る長大なものとなっています。

HTTP 1.1は1999年6月に公開されたRFC 2616ですが、
約15年経った今では様々な課題を抱えています。
特に当時は想定されていなかったWebブラウジング以外での
HTTPの利用が増えたことが大きいようです。

=== HTTP 1.1 の新RFCについて

RFCは同じ分野で新しい仕様を必要とした場合、
過去のRFCをobsolete（廃止）扱いとすることで
新しい（番号の大きな方の）RFCを利用するよう促します。

2014年6月に、このHTTP 1.1の仕様が
15年ぶりに改定されました。現在ではその内容が
下記のRFCとして公開されています。

* RFC7230: Message Syntax and Routing
* RFC7231: Semantics and Content
* RFC7232: Conditional Requests
* RFC7233: Range Requests
* RFC7234: Caching
* RFC7235: Authentication
* RFC7236:
* RFC7237:
* RFC7238:
* RFC7239:

(TODO: 概要説明)

この改定では、HTTPのバージョンが増えたわけではありません。
HTTP 1.1と呼ぶとき、今後はRFC 2616ではなく上記のRFCのみを参照するようにしてください。
ちなみに、
RFC 7230に関わっているMark Nottingham氏は自身のブログ記事"RFC2616 is Dead"（RFC2616 は死んだ）
@<fn>{mark_nottingham}で、
「RFC2616は使わないでください。ハードドライブ、ブックマークから削除し、
印刷されているなら全て燃やしてしまうかリサイクルに回しましょう」とまで書いています。 
HTTP 1.1について深く調べる際には、RFCを参照することはもちろんですが、関連記事を読む際に、古いRFCを元にしていないかを気にするのは良いことでしょう。@<fn>{old_rfc_wont_fade}

//footnote[mark_nottingham][@<href>{https://www.mnot.net/blog/2014/06/07/rfc2616_is_dead}]

//footnote[old_rfc_wont_fade][古いRFCを直接見ると、実はこのobsoleteとなったことに関する情報は記載されていません。これは利用者からみて少し面倒な事態を引き起こします。特にHTTP 1.1の古い側の仕様であるRFC 2616は現在でも公開されており、そこには、新しいRFC 7230〜7235を代わりに参照すべし、とは書いていません。一般的に公開されたRFC自体は一切修正されません。errataや別のRFCで上書きをするだけです。そのため、RFCを参照する側が情報収集を怠っていると、知らずのうちに古いRFCを参照する問題が発生します。さて執筆現在、Googleで「HTTP RFC」と検索します。すると、古い方のRFCが検索結果のトップとなります。長いこと参照されているのですから、ある意味当然です。しかし何も知らずにいると、それが実は参照してはいけないRFCだということに、気づくことがありません。他のWebサイトにおいてObsoleteとなったRFCは簡単に調べられますし、ニュースで取り上げられるケースもあります。単体のRFCを仕様書として絶対のものとは見ないようにしてください。]

=== HTTP 2.0 について

HTTP 2.0はHTTP 1.1の次バージョンとして標準化が行われている次のHTTP仕様です。
Googleが開発しているSPDFと呼ばれる仕組みを元にしています。

仕様策定としては最終段階にありますが、
「そもそもこれを公式の仕様とするべきではない」
と主張する人々もいます。


http://www.phoronix.com/scan.php?page=news_item&px=MTcwMTA

===[column] RFCへの「コメント」は誰でもできる

RFCが「仕様」ということで、
とても偉大で近づきがたい印象を持ってしまうこともあります。
筆者もその一人です。

ところで筆者は、あるRFCのワーキングループに積極的に参加したことがあります。
当時ある事情で特定のプロトコルを実装する必要があったのですが、
プロトコルに抜けがあって困っていました。
おそらく初期のバージョンでは検討から抜けていたのでしょう。

ちょうどその時、知り合いからそのプロトコルの次世代バージョンの
RFCが議論されていると聞き、個人のメールアドレスを使って
MLでの議論に参加することにしました。

変更としては非常にシンプルで説得力があったせいか、
特に何の異議もなく採用され、
RFCのAcknowledgementの項に名前が掲載されました。
こういうことは、普段ないだけに結構うれしいものです。

ここで大事なことは、
IETFでの議論は一般に広く開かれているということです。
迷惑と判断されるような行動をおこさなければ、
一介の技術者が世界的に使われる仕様に意見を出すことはいつでも可能です。

ただし、議論は英語です。

== HTTP
=== 基本のリクエストは「GET」と「POST」

Webサーバとやりとりする基本的なプロトコルであるHTTPでは、
クライアントからサーバへ要求（リクエスト、request）を送り、
サーバがそれに対する応答（レスポンス、response）を返します。

リクエストの種類について、HTTPにはたくさんの種類がありますが、
まず最初に学ぶべきは「GET」リクエストと「POST」リクエストです。
本章ではその他のリクエストについては詳細に立ち入りません。
例外として、RESTの項で説明します。

=== レスポンスコード

HTTPにおいて、Android端末のようなクライアントから
リクエストを送った際、サーバはその要求に対して
様々な返答を返します。

非常に典型的なのは「このWebページですね。どうぞ」と
「そんなWebページ、ない」という2種類の応答です。
URL

=== 演習: Android アプリからWebサーバにアクセスしてみよう

実際にAndroid経由でHTTPアクセスをしてみましょう。
ここでは@<code>{java.net.HttpURLConnection}を用いることにします。

===[column] DefaultHttpClientとAndroidHttpClient について

HTTPアクセスを行うライブラリは他にも@<code>{org.apache.http.impl.client.DefaultHttpClient}や
@<code>{android.net.http.AndroidHttpClient}といったライブラリが紹介されることがあります。
しかし本稿ではそれらの理由はおすすめしません。
現時点でこれらの実装にはバグが多く、今後もメンテナンスされる見込みがないと考えられているためです。
なお、非常に古いAndroidのバージョン（2.2）では@<code>{java.net.HttpURLConnection}にバグがあったため、
それらの古いバージョンでは注意が必要です。

 * 参考: Android Apache HTTP Client と HttpURLConnection どっちを使うべき？ @<href>{http://y-anz-m.blogspot.jp/2011/10/androidapache-http-client.html}@<fn>{this_is_also_old_article}


//footnote[this_is_also_old_article][記事の公開2011年10月4日に公開された点も出来れば]

=== Cookie

== HTML

== コードオンデマンド ... JavaScript


== REST
=== XML, JSON

HTTPにはWebサーバがどのようなタイプのデータを返すかを示す
Content-Type と呼ばれる情報を返します。

WebブラウザでWebページを見る場合、多くの場合HTMLが返されます。
しかしAndroid端末が情報を取得するばあい、
人が見るために整形されたHTMLを取得するのは冗長です。

そのため、機械が読み取りやすいデータ形式として、
しばしばXMLとJSONという形式を見ることになるでしょう。



== 関連トピック
=== SSL
==== UrlHttps を試す
=== 認証・認可

 * 認証: 本人確認
 * 認可: アクセス許可

コンピュータの世界から離れて役所で公的な証明書を受け取ることを考えてみます。
例えば、戸籍。

申請書類を書いて、免許証と申請書類を提出し、
役所が大丈夫だと思えば、役所が持っている情報を提供してくれます。

免許証を見せることは自分が本人であることの確認です。
もし「自分である」ことがわかれば、方法は複数あります。

しかし、見せたからと言って、申請する書類の許可が常に得られるとは限りません。



=== 実習: 天気の情報を取ってくる


== Webサーバの作られ方

基礎的な言葉については説明しました。
この節ではどのようにWebサーバが作られるかについて、
軽く触れることにしましょう。

=== 基本はHTTPのレスポンスを返すことと、データを長時間保存して共有すること

Android端末からはHTTPリクエストを送りますが、
サーバから見るとリクエストは「来る」ものです。
リクエストを読み取り、レスポンスを返すことが
サーバアプリケーションの基本的な役割です。

レスポンスのためのデータも保存します。
クライアントとしてのAndroid端末と異なり、
一つのサーバに複数のクライアントがアクセスし、
天気予報のような共有できるデータは共有します。
Web上の掲示板やTwitterのようなソーシャルサイト
でもやはり共有します。

「どのように」保存するかはサーバの用途に応じて選択されます。

例えば"Hello World"とだけテキスト形式でHTTPレスポンスを
返すWebサーバがあったとすると、サーバプログラムに
Hello Worldという文字を埋め込むだけで済みます。
サーバプログラムの外部に何かを「覚えて」おく仕組みを
用意する必要はありません。


いわゆる「データベース」のような、
データの保存に特化した仕組みを使って保存しておきます。


=== 自分でナマのレスポンスを記述することは減っている。

しかしHTTPはすでに大変複雑な技術と化しており、
更にサーバへアクセスしてくるWebブラウザ側の挙動に問題があったりするため
自力で全てを実装するのは難しくなっています。
特に高度なことを達成しようとすればするほど、
ミスが発生します。

また、特にセキュリティについて言えば、
いくつかの典型的な問題向けには取るべき定番の対策があります。
それを実現するための仕組みを、プログラミング言語や
Webサーバを作るためのフレームワークが提供しています。
例えばCSRF脆弱性の多くはPOST送信を行うフォーム等に
nonceを埋め込めば防げるため、Webフレームワークでは
nonceを自動生成して埋め込む仕組み、
それがないPOSTリクエストを遮断する仕組みがあったりします。
@<fn>{csrf_token}
@<fn>{not_all}

//footnote[csrf_token][PythonのWebフレームワークであるDjangoにはそのものずばり、csrf_tokenという仕組みがあり、POSTリクエストはこれが含まれていない場合、標準で一律に遮断されます。]

//footnote[not_all][では全ての脆弱性をフレームワークなどで防げるかと言いますと、答えは「いいえ」です]

=== IaaS: Webサーバ開発者のつよーい味方


=== 演習: 作ってみる


== その他のサーバ

本章はWebサーバについての説明を中心としてきました。
しかしインターネット・クラウド上にあるサーバは
それだけにとどまりません。

その他のサーバの例としては次のようなものもあります。

 * メールサーバ
 * ファイルサーバ
 * プリントサーバ

「プリントサーバ」について補足しましょう。

Word文書を印刷したりするために、プリンタを利用することは多いと思います。
昔のプリンタはUSB接続やその他の接続でPC1台とつながりませんでした。
しかし業務用プリンタや最近のプリンタは賢く、
複数台のパソコンやAndroid端末などから「このデータを印刷して」という要求を受けて、印刷を行います。
リクエストを受けて、レスポンスとして印刷するので、これもサーバです。

Webサーバと通信するためにプロトコルとして「HTTP」が重要でした。
同様に、各サーバではその用途に応じてプロトコルが必要です。

 * メールサーバ ... POP, IMAP, SMTPなど
 * プリントサーバ ... IPP, LPRなど
 * ファイルサーバ ... SMBなど

=== サーバの種類とユーザ視点

ユーザ視点で見ると、必ずしもサーバの分類が
明快に見えないこともあります。

例えばGMailはメールをやりとりするのに使いますが、
読者の多くはWebブラウザでメールを書いて送ります。
さてこの場合、GMailはWebサーバなのか、メールサーバなのか。

この場合、GMailはWebサーバとして、
後述するHTTPに則ってWebページをやりとりします。
ユーザがメールを編集するのも、送信ボタンを押すのも、
HTTP経由で送られるHTML上での操作ですから、
ここはWebサーバの領域です。

一方、送信ボタンクリック後、GMailは要求された
メールに関する送信等の動作を行います。
このとき、実はGMailはメールサーバとして振舞っています。

一般的に「メールサーバ」と呼んだ場合、
そのサーバとクライアント（メールソフト、メーラ）間でのやりとりは
HTTPではなくPOP、IMAP、SMTPといったプロトコルで行います。
実はGMailはこの中でIMAPとSMTPもサポートしています。

GMailのような「Webサーバとしてメール
サービスはYahoo!やMicrosoftといった
会社が提供しており、一般的に「Webメール」と呼びます

Webメールというサービス自体はHTTPを介してブラウザとサーバが行うもので、この場合のサーバはWebサーバです。
メール送信ボタンを押したあと、Webメールの側はメールを中継したり配送したりする別のメールサーバにメールを送ります。
このときはメールサーバの一種として動作し、相手のメールサーバと通信する際にもメールサーバに関わるプロトコルを用います。

クライアント・サーバモデルではしばしば
コンピュータ同士での「対話」が発生しますが、
対話の方法を相手に応じて変更することで、
Webメールサービスはユーザの期待に答えます。

Webページから編集するほかに、使い慣れたメールソフトでも送受信を行いたい、という要求があります。
このとき、例えばAndroid付随のメールソフトや
iOSのメールソフトや、ThunderbirdやOutlookといったソフトからGMailや
その他のWebメールサービスに接続できます。
このときのプロトコルはHTTPではなく
多くの場合POP, IMAP, SMTPとなりますから、
Webメールサービスは純粋にメールサーバとして
動作することになります。


== さらなる学習のために

Webサーバの周辺技術は多岐に渡ります。

本章ではAndroidから見たWebサーバを理解することが目的でした。
そのようなわけで、HTTPやURI、HTMLという「相互のやりとりのためのプロトコル」
を中心に解説してきました。

参考書籍でも、Webサーバを作る側の技術解説ではなく、
相互運用について勉強になる資料を中心に紹介します。

 * 『HTTPの教科書』翔泳社
 * 『Webを支える技術』技術評論社
 * 『めんどうくさいWebセキュリティ』
  * 基本的な解説を読んで「簡単そう」と思ったら読んでみましょう。いわゆるコーナーケースの瑣末さとセキュリティの関係を理解するに連れて吐き気がしてきます。

本章執筆時点（2014年6月）でややこしいのは、すでに本章で紹介したHTTP 1.1の仕様改定があったことです。
HTTP 1.1という表現で差すものが実は変わっています。

それ以前に出版されたHTTP 1.1に関わる書籍は、
しばしば「既存のHTTP 1.1の問題」という形でRFC 2616に関わるHTTP 1.1の落とし穴や問題点を指摘しています。
しかし、新仕様自体でバグ修正されていたりして消滅しているため、
そういった問題点の多くは教養としても理解する意味が薄くなっているように感じられます。
@<fn>{http_20_will_solve}

//footnote[http_20_will_solve][来るHTTP 2.0（本稿執筆時点でも出ていません）が解決してくれるに違いない、という文面も見ました。1.1自身が変わるという可能性には気が付かなかった模様です。実際、バージョン番号まで決まって10年以上安定している仕様自体がまるっと修正されるとは思いませんよね]

新RFC公開前の書籍を読む際には、新RFCの該当する記述と対比しながら読む方が良い勉強になるかもしれません。
@<fn>{learning_rfc}

//footnote[learning_rfc][本章筆者は新RFCの記述方法の的確さに感動してしまい、本来本章で記述するべきAndroidに関わる内容よりも圧倒的に多くの時間を単なるHTTP 1.1の仕様理解とRFC読みに費やしてしまいました。「いいじゃんAndroidアプリでそこが問題になることはほとんどないよ」という事実には意識が向きませんでした。]
