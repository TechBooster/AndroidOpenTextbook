= Webサーバの詳細

本章ではWebとWebサーバについて、もう少し詳細に踏み込んでいきます。
@<fn>{author_is_not_expert}

//footnote[author_is_not_expert][特に本章は可能な限り最新かつ重要と思われる情報を盛り込んだつもりです。しかし残念ながら、Webの技術変化はすさまじく、一方筆者は本分野で全てを知るエキスパートとは言えない状態です。特に一部のセキュリティに関する話題について気合を入れて勉強したい人は、参考文献等も併せて読んでいただく必要があります。]

== めんどうくさいWeb

前章の説明を読むと、Webは単純に見えます。
しかし詳細に見ていくと一歩間違えると危険な状況に直面する状況が山ほどあります。

例えば以下のHTTPレスポンスを見てみます。
改行コードについては明示的に[CR]や[CR][LF]と明示しました。
@<fn>{from_tangled_web}

//footnote[from_tangled_web][『めんどうくさいWebセキュリティ』のp60からの引用です。]

//list[header_injection_example1][ヘッダインジェクションの例]{
HTTP/1.1 200 OK[CR][LF]
Set-Cookie: last_search_term=[CR][CR]<html><body><h1>Hi![CR][LF]
[CR][LF]
Action completed.
//}

特定のブラウザでは、これは以下のように見える可能性があります。
@<fn>{previous_section}

//footnote[previous_section][混ぜるのは意図的にしろ、CRとCRLFを間違えるなど人間ならやりがちです。前章のtelnetの例に至っては、わかっててやってます。]

//list[header_injection_example1_2][ヘッダインジェクションの例で改行を間違えて展開した場合]{
HTTP/1.1 200 OK
Set-Cookie: last_search_term=

<html><body><h1>Hi!

Action completed.
//}

このように解釈してしまった場合、本来意図した"Action completed."に変わって返答内容の先頭に想定外のHTMLが挟まったように見えます。
「ヘッダインジェクション」「ヘッダスプリッティング」といった名前で呼ばれる立派な脆弱性です。

HTTP 1.1の仕様と言えるRFC 2616は1999年に書かれました。「ドットコムバブル」の頃です。

それから時代と共にWebが進化する過程で、すでに述べたとおりWebも新しい用途に頻繁に使われるようになりました。
また、そもそものRFC 2616では現在ではあまり使われないか、悪用されると上記のような脆弱性
の元になるような機能があり、さらに特定のケースでの曖昧な記述が、
Webサーバやブラウザの挙動の違いを引き起こしたのです。
@<fn>{strict_web}

//footnote[strict_web][ちなみになんでもかんでも厳密であればいいのかと言われれば、普及の観点から言うとそうでもないようです。HTML4がぐっだぐだだったことから、マークアップ言語の厳密性を書き手に矯正するXMLベースのXHTMLという仕様が生まれました。当初はこれで決定打になるかと思いきや、今でもHTML 4.01が使われ、Web上ではあまり流行りませんでした。本章担当者の意見としては「書き手に厳密性を求めたら角をためて牛を殺すようなもの」という印象を持ちます。HTML5はHTML 4.01のように緩くHTMLを書けるように見えますが、マークアップ言語のゆるい部分のWebブラウザでの解釈ルールが実は厳密になっている、ということだそうです。XHTMLは今でもepubのような用途で使われているようです。ちなみに前章のtelnetの例でもCRLFを送るべき所でCRを送っていますので、「厳密」なサーバなら解釈してくれないでしょう。]



一般的に言えば、脆弱性の問題は古いライブラリやそれを使うアプリには残りがちで、一方HTTPのリクエストやレスポンスはユーザから直接見えません。
利便性を追求するために間違った挙動を許すと、それが見えないところでフィッシングサイトなどを手伝う結果になります。
上記の「ヘッダインジェクション」の脆弱性は、対応のまずいWebブラウザでは一切の警告が表示されることなく、全てのHTMLを攻撃者が書き換えられる可能性を意味しています。
当然、現在の最新のWebサーバやブラウザでは対応が行き届いている、はずです。

上記の例ではそもそも、仕様で認められないCRLF以外の改行コードを改行と認識しているから起きる問題です。
一方、たとえ仕様通りであっても、ユーザをトラブルに導きかねない状況はありえます。

一見してシンプルそうなURIについて考えてみます。
例えば@<href>{http://xn--t8jx73hngb.com/}と書かれた時に人間がこのURIが馴染みのあるWebサーバのものかそうでないかを判定できるでしょうか。
@<fn>{punycode}

//footnote[punycode][@<href>{http://お名前.com}をpunycodeを使って書いてみました。試したブラウザではpunycodeを日本語名に自動変換してくれました]

現在Webは世界中で利用されていますから、全ての端末にフォントがあるとは限りません。
フォントがない状態で豆腐が表示されるのを回避するためにpunycode込みのURIが表示されても、
正規のWebサイト化フィッシングサイトかを区別するのは、結構難しいように筆者には思えます。
例えば日本語を読めない人が日本語ドメインのWebサイトとそれに似たフィッシングサイトを見分けるにはどうすればよいでしょうか。
インターネット上のどんな場所でもUTF-8を使えばいいんじゃないか、という意見もあるのですが、
多国語の読めない文字は、脆弱性と組み合わさると結構悲惨です。何が正しい応答かすらわからないわけで。

Webサーバと通信しているクライアントアプリケーション（Androidアプリも含む）は、
こういったサーバサイドの問題に対してユーザへ二次被害を与える可能性があります。

最低でも、自分でHTTPクライアントを自作しよう、とはなるべく思わない方がよいでしょう。
併せて、使うならなるべく安定したライブラリを使う必要がある点も、ここで再度確認しておきましょう。

RESTでHTTP GETを使って値を取るくらいであれば良いのですが、
もし自分のサービスが（WebViewなどを通じて）Webサービスと密に結合している場合、
古いバージョンのAndroid端末をサポートから切る、という判断も必要になることがあります。

=== HTTP 1.1 の新RFC

HTTP 1.1の当初の仕様と言えるRFC 2616には、
曖昧さや現在のWebにそぐわない仕様が盛り込まれていることはよく知られていました。
HTTP 2.0という次世代の仕様が議論される中でも、この1.1の混乱を収束するための
改善版の議論が粛々と進められていたのです。

2014年6月に、このHTTP 1.1の仕様が15年ぶりに改定されました。
現在ではその内容が下記のRFCとして公開されています。

#@warn(HTTP 1.1の概要説明)

 * RFC7230: Message Syntax and Routing
 * RFC7231: Semantics and Content
 * RFC7232: Conditional Requests
 * RFC7233: Range Requests
 * RFC7234: Caching
 * RFC7235: Authentication



 * RFC7236:
 * RFC7237:
 * RFC7238:
 * RFC7239:

RFCは同じ分野で新しい仕様を必要とした場合、
過去のRFCをobsolete（廃止）扱いとすることで
新しい（番号の大きな方の）RFCを利用するよう促します。
旧RFCの内容が書き換わるわけではなく、新RFCの方に廃止扱いのRFCの番号が列挙される仕組みです。

今回の改定でHTTPのバージョンが変化したわけではありませんから、
HTTP 1.1と呼ぶとき、今後はRFC 2616ではなく上記のRFCのみを参照するようにしてください。
一連のRFCの策定にも関わっているMark Nottingham氏は自身のブログ記事"RFC2616 is Dead"（RFC2616 は死んだ）
@<fn>{mark_nottingham}で、
「RFC2616は使わないでください。ハードドライブ、ブックマークから削除し、
印刷されているなら全て燃やしてしまうかリサイクルに回しましょう」とまで書いています。 
HTTP 1.1について深く調べる際には、RFCを参照することはもちろんですが、関連記事を読む際に、古いRFCを元にしていないかを気にするのは良いことでしょう。@<fn>{old_rfc_wont_fade}

//footnote[mark_nottingham][@<href>{https://www.mnot.net/blog/2014/06/07/rfc2616_is_dead}]
//footnote[old_rfc_wont_fade][古いRFCを直接見ると、実はこのobsoleteとなったことに関する情報は記載されていません。これは利用者からみて少し面倒な事態を引き起こします。特にHTTP 1.1の古い側の仕様であるRFC 2616は現在でも公開されており、そこには、新しいRFC 7230〜7235を代わりに参照すべし、とは書いていません。一般的に公開されたRFC自体は一切修正されません。errataや別のRFCで上書きをするだけです。そのため、RFCを参照する側が情報収集を怠っていると、知らずのうちに古いRFCを参照する問題が発生します。さて執筆現在、Googleで「HTTP RFC」と検索します。すると、古い方のRFCが検索結果のトップとなります。長いこと参照されているのですから、ある意味当然です。しかし何も知らずにいると、それが実は参照してはいけないRFCだということに、気づくことがありません。他のWebサイトにおいてObsoleteとなったRFCは簡単に調べられますし、ニュースで取り上げられるケースもあります。単体のRFCを仕様書として絶対のものとは見ないようにしてください。]

バージョンが変化していないため、混乱が助長されるのではないか、という考え方も出来る気がします。
しかし筆者がざっと眺めた印象では、そのような懸念を払拭するほどに丹念に作られたRFCであると感じられます。

上記のRFCは過去の1.1の仕様の曖昧さを排除し、
明らかに誤りだった点について今後そういった実装を行わないよう釘をさしつつ、
過去のクライアントやサーバが間違った動作をしても対応できるよう注意が払われています。
また各RFCに過去のRFC 2616からの変更点が明記されており、
追加で誤解が発生しない点に至るまで、徹底的に考えられているという意味で、大変すぐれたRFCなのではないかと感じます。

RFCはそもそも何も知らない人がゼロから読む教科書ではありませんが、本書を一読した読者くらいであれば、
新HTTP 1.1の内容は良い勉強になるだろうと筆者は思います。
@<fn>{new_rfc_is_good}

//footnote[new_rfc_is_good][曖昧さがあるRFCというのは読んでいて非常に辛いものですが、ここまで広範に使われているWebの屋台骨を綺麗に作りなおしただけあって、本当にすごいですねこれ。はい。]


=== HTTP 2.0 

HTTP 2.0はHTTP 1.1の次バージョンとして標準化が行われている次のHTTP仕様です。
Googleが開発しているSPDFと呼ばれる仕組みを元にしています。
TSLを必須としつつ高速化するなど、大きな改善を盛り込んでいます。
HTTPbisというワーキンググループが仕様策定の作業を行っています。

HTTP 2.0仕様策定としては最終段階にあります。
一方、「そもそもHTTP 2.0はそのまま破棄して次の仕様を作り直すべきだ」と主張する人々もいます。
@<fn>{http20_thrown_out}

//footnote[http20_thrown_out][英語ですが、例えば @<href>{http://www.phoronix.com/scan.php?page=news_item&px=MTcwMTA} などを参照してください。]

===[column] RFCへの「コメント」は誰でもできる

筆者はHTTPとはあまり関係しない別のRFCのワーキングループに積極的に参加したことがあります。
実装上の課題があり、新仕様の一部に旧仕様の問題箇所の修正を入れて欲しかったのです。

変更としては非常にシンプルで説得力があったせいか、特に何の異議もなく採用されました。
最終的に、同RFCのAcknowledgementの項に名前が掲載されました。
普段こういうことはあまりないだけに、結構うれしいものです。

ここで大事なことは、IETFでの議論は一般に広く開かれているということです。
迷惑と判断されるような行動をおこさなければ、
一介の技術者が世界的に使われる仕様に意見を出すことはいつでも可能です。
議論は通常英語で行われます。

== インターネット上の仕様って、結局何なの

（この章は削除の可能性あり）@<fn>{very_ideological}

//footnote[very_ideological][この章は教科書的というよりは本章筆者の見解が強烈に反映されてます。特に批判的に読みましょう]

インターネットやWebは当初、学術論文の公開やディスカッションを世界的に補助する目的が強いものでした。
そのため、世界で共有されるされるものについては誰もが自由にやりとりできる、という世界観が現れているようです。
@<fn>{first_proposal_says_it}

//footnote[first_proposal_says_it][Tim Berners-Lee博士のWorldWideWebについての最初の提案（@<href>{http://www.w3.org/Proposal.html}）では、ネットワーク上で洗練された認可を行うことは目的ではない、ネットワークトラフィックは全て公開である、などと書かれています。]

しかし、今ではWebはビジネスでも大々的に使われ、今では人の情報を盗むことにまでメリットが見出されるようになったため、当初のWebの思想からはずいぶん遠のいた部分が生まれています。

インターネットが世界中で一つの蜘蛛の巣のようにつながっているためには、皆が共通の見解とそれに基づくルール（プロトコル）に従う必要があります。
それがなくなると、プロトコルの行き違いから世界は分断されてしまうのです。

分断は意図的に行われることもあれば、行き違いからそうなることもあります。
特定のWebブラウザでプロトコル準拠がなされないために適切に閲覧できなくなる状態は後者にあたります。
HTTP 1.1の新RFCが発行された背景には、後者のような意図しない分断はとにかく避けるべき、という考えがあるのは間違いありません。
逆に、RFCに準拠すると分断が発生することすらあります。

Googleを始めとしたIT系企業の中にはそういった標準化・共通化に熱心な組織もありますが、そうでない組織もあるのは事実でしょう。
かく言うGoogleも、一部のサービスは共通のHTTPを使いつつ、他サービスとの連携についての共通仕様の策定に非積極的なものを展開していたりすることもあります。
本当に難しいのは「サーバの開発も維持も、タダでできるわけじゃないんですよね」という話も「営利企業なので、設けないと株主怒るのよ」という話もすべてが無視できない世の中の現実ということなのでしょう。

本章筆者から言えるとりあえず最低限のメッセージとしては「すでに共通で使われている仕様の類を読まずにオレオレ実装をまかりとおすのは避けよう」ということです。

上記の込み入った状況では、悪意のプレイヤーにしても善意のプレイヤーにしても、すでに相当高度なことを強いられています。
この中で、言ってみれば「馬鹿なプレイヤー」は一方的に善意の優秀なプレイヤーの足を引っ張ります。

RFCで公開されている範囲は本当に自由に取得できるのですから、積極的にそこから始めるべきです。
技術者のスタートは、とりあえずそこからです。


== JavaScriptとWebアプリケーション


=== Androidネイティブアプリ V.S. Webアプリ！？

 * JavaScriptはWebサーバアクセス時にアプリを更新するようなもの。
 ** A/Bテストや頻繁なリリースを実現しやすい
 * JavaScriptからそもそも取得できない端末特有のデータがある場合、Webアプリ単体では無理
 ** 最適なUI。OSが提供する一貫した見栄えに揃えるにはネイティブアプリが圧倒的に楽
 ** ウェアラブルと呼ばれるようなさらに小さい端末ではメモリ使用量等も相まってWebブラウザを起動するのは難しくなってしまう
 * 速度や応答性に極限までこだわる場合、Android上のJavaですら忌避される
 ** ネイティブアプリ V.S. Webアプリなどと言われるが、技術的には「更にネイティブ」になることもあるし、サーバが全て自動的に処理して結果を静的に配信する完全自動化まで幅がある
 ** つまりこの二値比較はいろいろな意味で中途半端とも言えたり。
 * 目標とするサービスの全体像がわかる場合、そこからどの部分をネイティブアプリ的に実装するか、Webサーバに任せるかは決まってくる
 * 結局ケースバイケースですねぇ
 * 非常に一般論で言えば、既存の多くの領域がWebアプリと呼ばれる領域に向かっていく可能性はあると筆者は考える
 ** 利用事例が固まってくると、それに応じて標準化された利用方法、API、仕様が決まり、WebサーバとJavaScriptでそれが容易に利用できるようになるため
 * Webや車載アプリのような、さらにAndroidの世界を広げる用途において、「ネイティブ」なアプリは常に求められることになると予想している


