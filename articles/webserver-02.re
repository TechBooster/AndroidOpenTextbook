= Webサーバ (H)

本章では知識を補強するための詳細について踏み込んでいきます。

前章では概要でとどめておいたWebサーバに関わる仕様について、踏み込んで説明していきます。

== RFC

前章で、相手がいるときには仕様が必要と説明しました。
RFCは特にインターネットやWebに関わる仕様を議論する際に非常にしばしば登場するフォーマットの一つです。

RFCと称されるドキュメントはたくさんあり、それぞれに連番がふられています。
「RFC」のあとに数字をつけ、例えば「RFC 7230」といった形で
特定のRFCを参照します。@<fn>{many_rfc}

//footnote[many_rfc][現時点でも7000を越えるRFC文書があるのは事実ですが、全部がインターネットで活用されている、というわけではありません。特にエイプリルフールに発行されるRFCの中には完全にジョークのものがあります。1998年に公開されたRFC 2324の"Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)"などはわかりやすい一例です。同RFCの2.3.2 "418 I'm a teapot"は私が学生時代に衝撃を受けた記憶があります。HTTPレスポンス418番は、実用的なWebサーバが返答することはまずありません。同RFCの1章に記述されている"there is a strong, dark, rich requirement for a protocol designed @<b>{espressoly} for the brewing of coffee"（強調引用者）という表現から誰しもがコーヒーの芳醇な香りを想起しつつ、次へ。]

Request For Commentsは日本語に訳すと「コメント求む」なのですが、
実際には各RFCの文書は公開される前に多くの議論を経た上で公開され、公開後に大きな修正は行われません。
そういう意味では、各ドキュメントは「コメント求む」という表現から想像するよりも
はるかに成熟したものです。

仮に改善の必要があった場合には、誤りについてはerrataとして公開されますが、
不足や根本的な改善については次のRFCを議論し、過去のRFCを打ち消す形で次に活かします。

=== WebとRFCと仕様

Webに関する動作を丹念に見るにはRFCを始めとした仕様の理解は欠かせません。

技術書籍やWeb上の解説記事を参照しつつも、最終的に相互のやりとりを行う上では仕様がベースになります。
特に、大人数が扱う複雑なシステムにおいては仕様が最後の拠り所になる点は覚えておきましょう。
Web上ではその拠り所がしばしばRFCとなるわけです。

== URI, URL, URNの詳細

URL（Universal Resource Locator）という表現の方を多く見るかもしれません。
ただし、現在、WebサーバーやHTTPの仕様上で使われるのはURIの方です。

歴史的にはURLという概念が先に登場しました。
1999年に発行されたHTTP 1.1の古い側の仕様にあたるRFC 2616でもURLという表現が使われています。

しかし2000年代までに行われた議論によって、
世界全体でのリソースの識別にLocation（位置）だけでなくName（名前）
導入するべきではないか、という流れになったようです。
その際、URLという概念に加えてURN（Universal Resource Name）も追加され、
それらをまとめる形としてURIという表現が生まれました。
なお、議論のさなかには他にもURIに含まれるべきものがあるといった意見もあったようです。
URIについてはRFC 3305に詳細な説明があります。

HTTP 1.1の新しい方の仕様であるRFC 7230〜7239では一律にURIを使用しています。

お話を進める前に、馴染みが薄いと思われるURNについて説明しましょう。

例えば本のISBN番号を表現するために"urn:isbn:4844335340"というURNを用いることができます。
このURNによって、某社の某書籍の存在を曖昧さなしに表現できます。

ただし、これではWeb上のどこにその本の情報があるか、どこで購入できるか、といった場所についての情報は含まれません。
Web上の場所を指す場合にはここでURLに相当するURIを使用します。
urn:isbn:4844335340 をAmazon上で見るには@<href>{http://www.amazon.co.jp/dp/4844335340}をどうぞ、といった説明ができます。

URNは登録制なので勝手に使用はできません。
ISBNとurnの対応は予めそのような取り決めがなされているために成立します。
そのため一般の人が自分の持つリソースのために使うにはURL（相当のURI）と比べると大変敷居が高い、といえると思います。

ただ、一度登録されたものについてはそれがなんであるかが曖昧さなしに決まるという特長は技術的にしばしば役に立ちます。
特に技術上曖昧さを排したい仕様名や仕様の中の概念に使われるケースを見ることが多いと思われます。

RFCという言葉について考えてみましょう。例えば、RFC1458という文字列からはRequest For Commentsの1458番という文書のことだと予想が一応立ちます。
しかし実はラジオ福島のことかもしれません。蛇足になりますが@<href>{http://www.ustream.tv/user/rfc1458}というURIは存在し、どうやらこれはラジオ福島のユーザアカウント情報を表示するWebページを参照できます。
要は「RFC1458」では一意とは言い切れません。
urn:ietf:rfc:1458であれば絶対にラジオ福島の方を差しません。

URNは古い用法としての「URL」としての役割を果たすわけではなく、場所がわからないのでHTMLのhrefとして記述してもWebブラウザは多分どこにも移動してくれません。
URIということで<a href="urn:ietf:rfc:1458">RFC 1458</a>と書いてもこのリンクはWebブラウザ上では意味がないでしょう。

厳密には全てURIで統一するのが適切です。
しかし今でもURLという表現がWebサーバやその周辺実装に使われており、
この2つの混同は大抵の場合あまり問題にならないようにも見えます。

Javaのライブラリでも、特にJavaの初期に実装されたものにはURLという名前のものが多く見られます。
後述する@<code>{java.net.HttpURLConnection}もURLと名前についています。

古くから使われるライブラリや古い仕様ではこのあたりの区別は曖昧であるため、
読者はURLとURIの違いについて知りつつ、
相手側がその用法について混乱している場合には本来の意図を問うのが優れていると、本章筆者は考えます。

=== Bonus!! JavaのURLクラスとURIクラス

Javaには両方のクラスがありますね！

ここで筆者としては紹介せずにいられないJava Puzzleがあります。

http://youtu.be/wDN_EYUvUq0?t=9m50s

相当古い動画なのですが、仕様上今でも問題になるURLクラスとURIクラスのSet内挙動が異なる点を
指摘した例として、当時新入社員だった筆者としても大変驚いた記憶があります。
この挙動の違いは本章のWebサーバの議論とはあまり関係はなく、

調べたところ、URLクラスはJDK1.0、URIクラスは1.4の導入とのことです。

どちらかというと初期のJavaのライブラリ設計の失敗に関わるものですが、
「古い」というのはしばしばそういう問題も引き起こす、ということで一つ。


== HTTP

=== HTTPのRFCと改定

HTTPも進化を伴いました。
執筆時点ではHTTPには0.9, 1.0, 1.1があります。
現在2.0の仕様策定中ですが、完成はしていません。

HTTP 0.9が極めてシンプルだったものであったのに対して、
HTTP 1.1の仕様にあたるRFC 2616では、
TXTファイルのページ数にして
実質176ページに渡る長大なものとなっています。

HTTP 1.1は1999年6月に公開されたRFC 2616ですが、
約15年経った今では様々な課題を抱えています。
特に当時は想定されていなかったWebブラウジング以外での
HTTPの利用が増えたことが大きいようです。

=== HTTP 1.1 の新RFC

RFCは同じ分野で新しい仕様を必要とした場合、
過去のRFCをobsolete（廃止）扱いとすることで
新しい（番号の大きな方の）RFCを利用するよう促します。

2014年6月に、このHTTP 1.1の仕様が15年ぶりに改定されました。
現在ではその内容が下記のRFCとして公開されています。

* RFC7230: Message Syntax and Routing
* RFC7231: Semantics and Content
* RFC7232: Conditional Requests
* RFC7233: Range Requests
* RFC7234: Caching
* RFC7235: Authentication
* RFC7236:
* RFC7237:
* RFC7238:
* RFC7239:

(TODO: 概要説明)

この改定では、HTTPのバージョンが変化したわけではありません。
HTTP 1.1と呼ぶとき、今後はRFC 2616ではなく上記のRFCのみを参照するようにしてください。

一連のRFCの策定にも関わっているMark Nottingham氏は自身のブログ記事"RFC2616 is Dead"（RFC2616 は死んだ）
@<fn>{mark_nottingham}で、
「RFC2616は使わないでください。ハードドライブ、ブックマークから削除し、
印刷されているなら全て燃やしてしまうかリサイクルに回しましょう」とまで書いています。 
HTTP 1.1について深く調べる際には、RFCを参照することはもちろんですが、関連記事を読む際に、古いRFCを元にしていないかを気にするのは良いことでしょう。@<fn>{old_rfc_wont_fade}

//footnote[mark_nottingham][@<href>{https://www.mnot.net/blog/2014/06/07/rfc2616_is_dead}]
//footnote[old_rfc_wont_fade][古いRFCを直接見ると、実はこのobsoleteとなったことに関する情報は記載されていません。これは利用者からみて少し面倒な事態を引き起こします。特にHTTP 1.1の古い側の仕様であるRFC 2616は現在でも公開されており、そこには、新しいRFC 7230〜7235を代わりに参照すべし、とは書いていません。一般的に公開されたRFC自体は一切修正されません。errataや別のRFCで上書きをするだけです。そのため、RFCを参照する側が情報収集を怠っていると、知らずのうちに古いRFCを参照する問題が発生します。さて執筆現在、Googleで「HTTP RFC」と検索します。すると、古い方のRFCが検索結果のトップとなります。長いこと参照されているのですから、ある意味当然です。しかし何も知らずにいると、それが実は参照してはいけないRFCだということに、気づくことがありません。他のWebサイトにおいてObsoleteとなったRFCは簡単に調べられますし、ニュースで取り上げられるケースもあります。単体のRFCを仕様書として絶対のものとは見ないようにしてください。]

バージョンが変化していないため、混乱が助長されるのではないか、という考え方も出来ます。
しかし筆者がざっと眺めた印象では、そのような懸念を払拭するほどに丹念に作られた仕様と感じられます。

上記のRFCは過去の1.1の仕様の曖昧さを排除し、
明らかに誤りだった点について今後そういった実装を行わないよう釘をさしつつ、
過去のクライアントやサーバが間違った動作をしても対応できるよう注意が払われています。
また各RFCに過去のRFC 2616からの変更点が明記されており、
追加で誤解が発生しない点に至るまで、徹底的に考えられているという意味で、大変すぐれたRFCなのではないかと感じます。

RFCはそもそも何も知らない人がゼロから読む教科書ではありませんが、本書を一読した読者くらいであれば、
新HTTP 1.1の内容は良い勉強になるだろうと筆者は思います。
@<fn>{new_rfc_is_good}

//footnote[new_rfc_is_good][曖昧さがあるRFCというのは読んでいて非常に辛いものですが、ここまで広範に使われているWebの屋台骨を綺麗に作りなおしただけあって、本当にすごいですねこれ。はい。]


=== HTTP 2.0 について

HTTP 2.0はHTTP 1.1の次バージョンとして標準化が行われている次のHTTP仕様です。
Googleが開発しているSPDFと呼ばれる仕組みを元にしています。
TSLを必須としつつ高速化するなど、大きな改善を盛り込んでいます。

HTTP 2.0仕様策定としては最終段階にありますが、
「そもそもこれを公式の仕様とするべきではない」
と主張する人々もいます。@<fn>{http20_thrown_out}

//footnote[http20_thrown_out][英語ですが、例えば @<href>{http://www.phoronix.com/scan.php?page=news_item&px=MTcwMTA} などを参照してください。]

===[column] RFCへの「コメント」は誰でもできる

RFCが「仕様」ということで、
とても偉大で近づきがたい印象を持ってしまうこともあります。
筆者もその一人です。

ところで筆者は、あるRFCのワーキングループに積極的に参加したことがあります。
当時ある事情で特定のプロトコルを実装する必要があったのですが、
プロトコルに抜けがあって困っていました。
おそらく初期のバージョンでは検討から抜けていたのでしょう。

ちょうどその時、知り合いからそのプロトコルの次世代バージョンの
RFCが議論されていると聞き、個人のメールアドレスを使って
MLでの議論に参加することにしました。

変更としては非常にシンプルで説得力があったせいか、
特に何の異議もなく採用され、RFCのAcknowledgementの項に名前が掲載されました。
普段こういうことはあまりないだけに、結構うれしいものです。

ここで大事なことは、IETFでの議論は一般に広く開かれているということです。
迷惑と判断されるような行動をおこさなければ、
一介の技術者が世界的に使われる仕様に意見を出すことはいつでも可能です。

ただし、議論は英語です。
