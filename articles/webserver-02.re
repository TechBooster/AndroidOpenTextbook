= Webサーバの詳細

本章ではWebとWebサーバについて、もう少し詳細に踏み込んでいきます。
@<fn>{author_is_not_expert}

//footnote[author_is_not_expert][特に本章は可能な限り最新かつ重要と思われる情報を盛り込んだつもりです。しかし残念ながら、Webの技術変化はすさまじく、一方筆者は本分野で全てを知るエキスパートとは言えない状態です。特に一部のセキュリティに関する話題について気合を入れて勉強したい人は、参考文献等も併せて読んでいただく必要があります。]

== 仕様
=== RFC をもう一度

前章で、相手がいるときには仕様が必要と説明しました。
RFCは特にインターネットやWebに関わる仕様を議論する際に非常にしばしば登場するフォーマットの一つです。

=== WebとRFCと仕様

Webに関する動作を丹念に見るにはRFCを始めとした仕様の理解は欠かせません。

技術書籍やWeb上の解説記事を参照しつつも、最終的に相互のやりとりを行う上では仕様がベースになります。
特に、大人数が扱う複雑なシステムにおいては仕様が最後の拠り所になる点は覚えておきましょう。
Web上ではその拠り所がしばしばRFCとなるわけです。

== HTTP

=== HTTPのRFCと改定

HTTPも進化を伴いました。
執筆時点ではHTTPには0.9, 1.0, 1.1があります。
現在2.0の仕様策定中ですが、完成はしていません。

HTTP 0.9が極めてシンプルだったものであったのに対して、
HTTP 1.1の仕様にあたるRFC 2616では、
TXTファイルのページ数にして
実質176ページに渡る長大なものとなっています。

HTTP 1.1は1999年6月に公開されたRFC 2616ですが、
約15年経った今では様々な課題を抱えています。
特に当時は想定されていなかったWebブラウジング以外での
HTTPの利用が増えたことが大きいようです。

=== HTTP 1.1 の新RFC

RFCは同じ分野で新しい仕様を必要とした場合、
過去のRFCをobsolete（廃止）扱いとすることで
新しい（番号の大きな方の）RFCを利用するよう促します。

2014年6月に、このHTTP 1.1の仕様が15年ぶりに改定されました。
現在ではその内容が下記のRFCとして公開されています。

#@warn(HTTP 1.1の概要説明)

 * RFC7230: Message Syntax and Routing
 * RFC7231: Semantics and Content
 * RFC7232: Conditional Requests
 * RFC7233: Range Requests
 * RFC7234: Caching
 * RFC7235: Authentication
 * RFC7236:
 * RFC7237:
 * RFC7238:
 * RFC7239:



この改定では、HTTPのバージョンが変化したわけではありません。
HTTP 1.1と呼ぶとき、今後はRFC 2616ではなく上記のRFCのみを参照するようにしてください。

一連のRFCの策定にも関わっているMark Nottingham氏は自身のブログ記事"RFC2616 is Dead"（RFC2616 は死んだ）
@<fn>{mark_nottingham}で、
「RFC2616は使わないでください。ハードドライブ、ブックマークから削除し、
印刷されているなら全て燃やしてしまうかリサイクルに回しましょう」とまで書いています。 
HTTP 1.1について深く調べる際には、RFCを参照することはもちろんですが、関連記事を読む際に、古いRFCを元にしていないかを気にするのは良いことでしょう。@<fn>{old_rfc_wont_fade}

//footnote[mark_nottingham][@<href>{https://www.mnot.net/blog/2014/06/07/rfc2616_is_dead}]
//footnote[old_rfc_wont_fade][古いRFCを直接見ると、実はこのobsoleteとなったことに関する情報は記載されていません。これは利用者からみて少し面倒な事態を引き起こします。特にHTTP 1.1の古い側の仕様であるRFC 2616は現在でも公開されており、そこには、新しいRFC 7230〜7235を代わりに参照すべし、とは書いていません。一般的に公開されたRFC自体は一切修正されません。errataや別のRFCで上書きをするだけです。そのため、RFCを参照する側が情報収集を怠っていると、知らずのうちに古いRFCを参照する問題が発生します。さて執筆現在、Googleで「HTTP RFC」と検索します。すると、古い方のRFCが検索結果のトップとなります。長いこと参照されているのですから、ある意味当然です。しかし何も知らずにいると、それが実は参照してはいけないRFCだということに、気づくことがありません。他のWebサイトにおいてObsoleteとなったRFCは簡単に調べられますし、ニュースで取り上げられるケースもあります。単体のRFCを仕様書として絶対のものとは見ないようにしてください。]

バージョンが変化していないため、混乱が助長されるのではないか、という考え方も出来ます。
しかし筆者がざっと眺めた印象では、そのような懸念を払拭するほどに丹念に作られた仕様と感じられます。

上記のRFCは過去の1.1の仕様の曖昧さを排除し、
明らかに誤りだった点について今後そういった実装を行わないよう釘をさしつつ、
過去のクライアントやサーバが間違った動作をしても対応できるよう注意が払われています。
また各RFCに過去のRFC 2616からの変更点が明記されており、
追加で誤解が発生しない点に至るまで、徹底的に考えられているという意味で、大変すぐれたRFCなのではないかと感じます。

RFCはそもそも何も知らない人がゼロから読む教科書ではありませんが、本書を一読した読者くらいであれば、
新HTTP 1.1の内容は良い勉強になるだろうと筆者は思います。
@<fn>{new_rfc_is_good}

//footnote[new_rfc_is_good][曖昧さがあるRFCというのは読んでいて非常に辛いものですが、ここまで広範に使われているWebの屋台骨を綺麗に作りなおしただけあって、本当にすごいですねこれ。はい。]



=== HTTP 2.0 について

HTTP 2.0はHTTP 1.1の次バージョンとして標準化が行われている次のHTTP仕様です。
Googleが開発しているSPDFと呼ばれる仕組みを元にしています。
TSLを必須としつつ高速化するなど、大きな改善を盛り込んでいます。

HTTP 2.0仕様策定としては最終段階にありますが、
「そもそもこれを公式の仕様とするべきではない」
と主張する人々もいます。@<fn>{http20_thrown_out}

//footnote[http20_thrown_out][英語ですが、例えば @<href>{http://www.phoronix.com/scan.php?page=news_item&px=MTcwMTA} などを参照してください。]

===[column] RFCへの「コメント」は誰でもできる

RFCが「仕様」ということで、
とても偉大で近づきがたい印象を持ってしまうこともあります。
筆者もその一人です。

ところで筆者は、あるRFCのワーキングループに積極的に参加したことがあります。
当時ある事情で特定のプロトコルを実装する必要があったのですが、
プロトコルに抜けがあって困っていました。
おそらく初期のバージョンでは検討から抜けていたのでしょう。

ちょうどその時、知り合いからそのプロトコルの次世代バージョンの
RFCが議論されていると聞き、個人のメールアドレスを使って
MLでの議論に参加することにしました。

変更としては非常にシンプルで説得力があったせいか、
特に何の異議もなく採用され、RFCのAcknowledgementの項に名前が掲載されました。
普段こういうことはあまりないだけに、結構うれしいものです。

ここで大事なことは、IETFでの議論は一般に広く開かれているということです。
迷惑と判断されるような行動をおこさなければ、
一介の技術者が世界的に使われる仕様に意見を出すことはいつでも可能です。

ただし、議論は英語です。

== インターネット上の仕様って、結局何なの

（この章は削除の可能性あり）@<fn>{very_ideological}

//footnote[very_ideological][この章は教科書的というよりは本章筆者の見解が強烈に反映されてます。特に批判的に読みましょう]

インターネットやWebは当初、学術論文の公開やディスカッションを世界的に補助する目的が強いものでした。
そのため、世界で共有されるされるものについては誰もが自由にやりとりできる、という世界観が現れているようです。
@<fn>{first_proposal_says_it}

//footnote[first_proposal_says_it][Tim Berners-Lee博士のWorldWideWebについての最初の提案（@<href>{http://www.w3.org/Proposal.html}）では、ネットワーク上で洗練された認可を行うことは目的ではない、ネットワークトラフィックは全て公開である、などと書かれています。]

しかし、今ではWebはビジネスでも大々的に使われ、今では人の情報を盗むことにまでメリットが見出されるようになったため、当初のWebの思想からはずいぶん遠のいた部分が生まれています。

インターネットが世界中で一つの蜘蛛の巣のようにつながっているためには、皆が共通の見解とそれに基づくルール（プロトコル）に従う必要があります。
それがなくなると、プロトコルの行き違いから世界は分断されてしまうのです。

分断は意図的に行われることもあれば、行き違いからそうなることもあります。
特定のWebブラウザでプロトコル準拠がなされないために適切に閲覧できなくなる状態は後者にあたります。
HTTP 1.1の新RFCが発行された背景には、後者のような意図しない分断はとにかく避けるべき、という考えがあるのは間違いありません。
逆に、RFCに準拠すると分断が発生することすらあります。

Googleを始めとしたIT系企業の中にはそういった標準化・共通化に熱心な組織もありますが、そうでない組織もあるのは事実でしょう。
かく言うGoogleも、一部のサービスは共通のHTTPを使いつつ、他サービスとの連携についての共通仕様の策定に非積極的なものを展開していたりすることもあります。
本当に難しいのは「サーバの開発も維持も、タダでできるわけじゃないんですよね」という話も「営利企業なので、設けないと株主怒るのよ」という話もすべてが無視できない世の中の現実ということなのでしょう。

本章筆者から言えるとりあえず最低限のメッセージとしては「すでに共通で使われている仕様の類を読まずにオレオレ実装をまかりとおすのは避けよう」ということです。

上記の込み入った状況では、悪意のプレイヤーにしても善意のプレイヤーにしても、すでに相当高度なことを強いられています。
この中で、言ってみれば「馬鹿なプレイヤー」は一方的に善意の優秀なプレイヤーの足を引っ張ります。

RFCで公開されている範囲は本当に自由に取得できるのですから、積極的にそこから始めるべきです。
技術者のスタートは、とりあえずそこからです。


== JavaScriptとWebアプリケーション


=== Androidネイティブアプリ V.S. Webアプリ！？

 * JavaScriptはWebサーバアクセス時にアプリを更新するようなもの。
 ** A/Bテストや頻繁なリリースを実現しやすい
 * JavaScriptからそもそも取得できない端末特有のデータがある場合、Webアプリ単体では無理
 ** 最適なUI。OSが提供する一貫した見栄えに揃えるにはネイティブアプリが圧倒的に楽
 ** ウェアラブルと呼ばれるようなさらに小さい端末ではメモリ使用量等も相まってWebブラウザを起動するのは難しくなってしまう
 * 速度や応答性に極限までこだわる場合、Android上のJavaですら忌避される
 ** ネイティブアプリ V.S. Webアプリなどと言われるが、技術的には「更にネイティブ」になることもあるし、サーバが全て自動的に処理して結果を静的に配信する完全自動化まで幅がある
 ** つまりこの二値比較はいろいろな意味で中途半端とも言えたり。
 * 目標とするサービスの全体像がわかる場合、そこからどの部分をネイティブアプリ的に実装するか、Webサーバに任せるかは決まってくる
 * 結局ケースバイケースですねぇ
 * 非常に一般論で言えば、既存の多くの領域がWebアプリと呼ばれる領域に向かっていく可能性はあると筆者は考える
 ** 利用事例が固まってくると、それに応じて標準化された利用方法、API、仕様が決まり、WebサーバとJavaScriptでそれが容易に利用できるようになるため
 * Webや車載アプリのような、さらにAndroidの世界を広げる用途において、「ネイティブ」なアプリは常に求められることになると予想している

== PKI
== SSL接続
=== UrlHttps を試す

== 認証・認可

 * 認証: 本人確認
 * 認可: アクセス許可

コンピュータの世界から離れて役所で公的な証明書を受け取ることを考えてみます。
例えば、戸籍。

申請書類を書いて、免許証と申請書類を提出し、
役所が大丈夫だと思えば、役所が持っている情報を提供してくれます。

免許証を見せることは自分が本人であることの確認です。
もし「自分である」ことがわかれば、方法は複数あります。

しかし、見せたからと言って、申請する書類の許可が常に得られるとは限りません。
あなたが誰であるか、とその人に何かを行う許可を与えることは別のことです。

== Webと脆弱性

Webは現在ではインターネットの中核を担う技術です。
それだけに、歴史的事情も絡んだ複雑な問題を多数抱えています。
ここまで、RFCを始めとした仕様レベルまで、ある程度詳細にWebに関する技術を説明してきましたが、
全ての既知の問題が解決されたわけではなく、むしろ状況がより複雑になっていく一方です。

「クロスサイト・スクリプティング」や「クロスサイト・リクエスト・フォージェリ」といった
代表的な脆弱性については繰り返し説明がなされることが多いので、
ここではもう少し低レベルなわかりづらいものを試しに挙げてみます。

例えば以下のHTTPレスポンスを見てみます。改行コードについては明示的に[CR][LF]と書いてあります。
@<fn>{from_tangled_web}

//footnote[from_tangled_web][『めんどうくさいWebセキュリティ』のp60からの引用です。]

//list[header_injection_example1][ヘッダインジェクションの例]{
HTTP/1.1 200 OK[CR][LF]
Set-Cookie: last_search_term=[CR][CR]<html><body><h1>Hi![CR][LF]
[CR][LF]
Action completed.
//}

特定のブラウザではこれは以下のように見える可能性があります。
@<fn>{previous_section}

//footnote[previous_section][混ぜるのは意図的にしろ、CRとCRLFを間違えるなど人間ならやりがちです。前章のtelnetの例に至っては、わかっててやってます。]

//list[header_injection_example1_2][ヘッダインジェクションの例で改行を間違えて展開した場合]{
HTTP/1.1 200 OK
Set-Cookie: last_search_term=

<html><body><h1>Hi!

Action completed.
//}

上記の問題はすでに主要なWebサーバやブラウザでは対応が行き届いています@<fn>{rfc7230_has_explanation}が、古いブラウザやライブラリでは必ずしもそうではありません。
また一般的に、同様の問題は古いライブラリやそれを使うアプリには残りがちです。

//footnote[rfc7230_has_explanation][HTTP 1.1の新RFCの一つであるRFC 7320では"9.4. Response Splitting"で一節割いてこの問題を説明し、典型的な対処策まで説明しています。]

たとえ仕様通りであっても、ユーザをトラブルに導きかねない状況はありえます。
一見してシンプルそうなURIについて考えてみます。例えば@<href>{http://xn--t8jx73hngb.com/}と書かれた時に
人間がこのURIが馴染みのあるWebサーバのものかそうでないかを判定できるでしょうか。
@<fn>{punycode}

//footnote[punycode][@<href>{http://お名前.com}をpunycodeを使って書いてみました。]

仮に人気の新サービスがアラビア文字のついたドメインのURIを持っていた際にはこのあたりの問題がリアルになるかもしれません。
フォントがない状態で豆腐が表示されるのを回避するためにpunycode込みのURIが表示されても、
正規のWebサイト化フィッシングサイトかを区別するのは、結構難しいように筆者には思えます。
@<fn>{recent_browsers_are_great}

//footnote[recent_browsers_are_great][最近ではブラウザがかなり丁寧にこのあたりに対策をしてくれています。しかし逆に言うと、URIをユーザフレンドリかつ安全に見せることすら、個人のレベルでは難しいことを示唆している気がします。]

本書はWebに関する包括的な教科書を意図していないので、あまり詳細には立ち入りません。
しかし、URI、HTTP、HTML、CSS等、どの側面を見ても、開発者やユーザを陥れる危険な落とし穴があります。

Webサーバと通信しているクライアントアプリケーション（Androidアプリも含む）は、
こういったサーバサイドの問題に対してユーザへ二次被害を与える可能性があります。

最低でも、自分でHTTPクライアントを自作しよう、とはなるべく思わない方がよいでしょう。
併せて、使うならなるべく安定したライブラリを使う必要がある点も、ここで再度確認しておきます。

RESTでHTTP GETを使って値を取るくらいであれば良いのですが、
もし自分のサービスが（WebViewなどを通じて）Webサービスと密に結合している場合、
古いバージョンのAndroid端末をサポートから切る、という判断も必要になることがあります。
